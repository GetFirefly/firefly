use crate::erts::exception::{ErlangException, RuntimeException};

use liblumen_core::util::thread_local::ThreadLocalCell;

/// This type is used to communicate error information between
/// the native code of a process, and the scheduler/caller.
///
/// Error info (when applicable) is communicated separately.
#[allow(unused)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum ProcessSignal {
    /// No signal set
    None = 0,
    /// The process should yield/has yielded
    Yield,
    /// Operation failed due to allocation failure,
    /// or process requires garbage collection
    GarbageCollect,
    /// The process raised an error
    Error,
    /// The process exited
    Exit,
}

extern "C-unwind" {
    #[link_name = "__lumen_process_signal"]
    #[thread_local]
    static mut PROCESS_SIGNAL: ProcessSignal;

    #[link_name = "__lumen_process_exception"]
    #[thread_local]
    #[allow(improper_ctypes)]
    static mut PROCESS_EXCEPTION: *mut ErlangException;

    #[allow(improper_ctypes)]
    #[link_name = "__lumen_panic"]
    fn lumen_panic(err: *mut ErlangException) -> !;
}

// Holds the current RuntimeException generated by the runtime, if present
thread_local!(static PROCESS_ERROR: ThreadLocalCell<Option<RuntimeException>> = ThreadLocalCell::new(None));

/// Returns the current value of the process signal
#[inline(always)]
pub fn process_signal() -> ProcessSignal {
    unsafe { PROCESS_SIGNAL }
}

/// Sets the process signal value
#[inline(always)]
pub fn set_process_signal(value: ProcessSignal) {
    unsafe {
        PROCESS_SIGNAL = value;
    }
}

/// Clears the process signal value
#[inline(always)]
pub fn clear_process_signal() {
    unsafe {
        PROCESS_SIGNAL = ProcessSignal::None;
    }
}

/// Returns the current value of the process exception pointer
#[inline(always)]
pub fn process_exception() -> *mut ErlangException {
    unsafe { PROCESS_EXCEPTION }
}

/// Sets the process exception pointer
#[inline(always)]
pub fn set_process_exception(ptr: *mut ErlangException) {
    unsafe {
        PROCESS_EXCEPTION = ptr;
    }
}

/// Clears the current value of the process exception pointer
#[inline(always)]
pub fn clear_process_exception() {
    unsafe {
        PROCESS_EXCEPTION = core::ptr::null_mut();
    }
}

pub fn process_raise(err: RuntimeException) -> ! {
    let erlang_exception = err.as_erlang_exception();
    let ptr = Box::into_raw(erlang_exception);
    set_process_exception(ptr);
    unsafe {
        PROCESS_ERROR.with(|cell| cell.replace(Some(err)));

        lumen_panic(ptr);
    }
}

/// Gets the process error value
#[inline]
pub fn process_error() -> Option<RuntimeException> {
    let exception = unsafe { PROCESS_ERROR.with(|cell| cell.replace(None)) };
    clear_process_exception();
    exception
}
