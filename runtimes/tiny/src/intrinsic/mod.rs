use core::ops::Deref;
use core::ptr::NonNull;
use std::sync::Arc;

use num_bigint::{BigInt, Sign};

use liblumen_alloc::gc::GcBox;
use liblumen_binary::{BinaryEntrySpecifier, BitVec, Bitstring};
use liblumen_rt::backtrace::Trace;
use liblumen_rt::error::ErlangException;
use liblumen_rt::function::ErlangResult;
use liblumen_rt::term::{atoms, Atom, BigInteger, BinaryData, BitSlice, Closure, Cons, Map, Tuple};
use liblumen_rt::term::{MatchContext, MatchResult};
use liblumen_rt::term::{OpaqueTerm, Term, TermType};

use crate::scheduler;

macro_rules! ok {
    ($value:expr) => {
        liblumen_rt::function::ErlangResult::Ok($value)
    };
}

macro_rules! err {
    ($value:expr) => {
        liblumen_rt::function::ErlangResult::Err($value)
    };
}

/// Constructs a new empty term of the given type and size on the current process heap
#[export_name = "__lumen_builtin_malloc"]
pub extern "C-unwind" fn malloc(kind: TermType, size: usize) -> *mut () {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        match kind {
            TermType::Cons => Cons::new_in(proc).unwrap().as_ptr().cast(),
            TermType::Tuple => Tuple::new_in(size, proc).unwrap().as_ptr().cast(),
            TermType::Map => GcBox::into_raw(Map::new_in(proc).unwrap()).cast(),
            TermType::Closure => {
                GcBox::into_raw(unsafe { Closure::with_capacity_in(size, proc).unwrap() }).cast()
            }
            ty => panic!("unexpected malloc type: {:?}", ty),
        }
    })
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
#[allow(dead_code)]
enum SignRaw {
    Minus = 0,
    NoSign,
    Plus,
}
impl Into<Sign> for SignRaw {
    fn into(self) -> Sign {
        match self {
            Self::Minus => Sign::Minus,
            Self::NoSign => Sign::NoSign,
            Self::Plus => Sign::Plus,
        }
    }
}

#[repr(C)]
pub struct BigIntRef {
    sign: SignRaw,
    digits: [u8],
}

/// Allocates a new BigInteger from constant data produced by the compiler
#[export_name = "__lumen_bigint_from_digits"]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn bigint_from_digits(raw: &BigIntRef) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        GcBox::new_in(
            BigInteger(BigInt::from_bytes_be(raw.sign.into(), &raw.digits[..])),
            proc,
        )
        .unwrap()
        .into()
    })
}

/// A combined tuple type test with fetching the arity, optimized for a specific pattern
/// produced by the compiler
#[export_name = "__lumen_tuple_size"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn tuple_size(term: OpaqueTerm) -> ErlangResult<u32, ()> {
    term.tuple_size()
}

/// A tuple constructor optimized for construction sequences generated by the compiler
#[export_name = "__lumen_make_tuple"]
pub extern "C-unwind" fn make_tuple(arity: usize) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        Tuple::new_in(arity, proc).unwrap().into()
    })
}

/// Intrinsic equivalent to erlang:setelement/3 that is optimized for cases in
/// which the callee is known to have a tuple reference and an immediate index,
/// allowing us to bypass the overhead of checking types on those two arguments.
///
/// NOTE: This is intended only for use by the code generator as a compiler intrinsic,
/// callers from Rust code should use the standard Tuple APIs. This is NOT safe to be
/// called from arbitrary user code, as it does not validate its invariants, and therefore
/// will result in undefined behavior if any of them are violated.
#[export_name = "__lumen_set_element"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn setelement(tuple: &Tuple, index: usize, value: OpaqueTerm) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        tuple.set_element(index, value, proc).unwrap().into()
    })
}

/// Constructs a new empty map on the current process heap
#[export_name = "__lumen_map_empty"]
pub extern "C-unwind" fn map_empty() -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        Map::new_in(proc).unwrap().into()
    })
}

#[export_name = "__lumen_map_put"]
pub extern "C-unwind" fn map_put(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> OpaqueTerm {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            let updated = GcBox::new_in(m.insert(key.into(), value.into()), proc).unwrap();
            updated.into()
        }),
        _ => panic!("unexpected argument given to map_put bif"),
    }
}

#[export_name = "__lumen_map_put_mut"]
pub extern "C-unwind" fn map_put_mut(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> OpaqueTerm {
    match map.into() {
        Term::Map(mut m) => {
            m.insert_mut(key.into(), value.into());
            map
        }
        _ => panic!("unexpected argument given to map_put bif"),
    }
}

#[export_name = "__lumen_map_update"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_update(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> ErlangResult {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            match m.insert_new(key.into(), value.into()) {
                None => err!(map_error(key, Trace::capture())),
                Some(updated) => ok!(GcBox::new_in(updated, proc).unwrap().into()),
            }
        }),
        _ => panic!("unexpected argument given to map_update bif"),
    }
}

#[export_name = "__lumen_map_update_mut"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_update_mut(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> ErlangResult {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            match m.insert_new(key.into(), value.into()) {
                None => err!(map_error(key, Trace::capture())),
                Some(updated) => ok!(GcBox::new_in(updated, proc).unwrap().into()),
            }
        }),
        _ => panic!("unexpected argument given to map_update_mut bif"),
    }
}

#[inline]
fn map_error(key: OpaqueTerm, trace: Arc<Trace>) -> NonNull<ErlangException> {
    let exception = ErlangException::new(atoms::Error, key.into(), trace);
    unsafe { NonNull::new_unchecked(Box::into_raw(exception)) }
}

/// This builtin differs from erlang:map_get/2 in that it is only called in contexts where
/// we've already type checked the map, and we're simply fetching the given key from the map
#[export_name = "__lumen_map_fetch"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_fetch(
    map: OpaqueTerm,
    key: OpaqueTerm,
) -> ErlangResult<OpaqueTerm, ()> {
    match map.into() {
        Term::Map(m) => {
            let key: Term = key.into();
            m.get(&key).map(|t| t.into()).ok_or(()).into()
        }
        _ => err!(()),
    }
}

#[export_name = "__lumen_build_stacktrace"]
pub unsafe extern "C-unwind" fn build_stacktrace(mut trace: NonNull<Trace>) -> OpaqueTerm {
    let term = trace.as_mut().as_term().unwrap();
    term.into()
}

#[export_name = "__lumen_builtin_raise/3"]
pub extern "C-unwind" fn raise(
    kind: OpaqueTerm,
    reason: OpaqueTerm,
    trace: *mut Trace,
) -> *mut ErlangException {
    debug_assert!(!trace.is_null());
    let trace = unsafe { Trace::from_raw(trace) };
    let kind: Term = kind.into();
    let kind: Atom = kind.try_into().unwrap();
    let exception = match kind.as_str() {
        "throw" | "error" | "exit" => ErlangException::new(kind, reason.into(), trace),
        other => panic!("invalid exception kind: {}", &other),
    };
    Box::into_raw(exception)
}

#[export_name = "__lumen_cleanup_exception"]
pub extern "C-unwind" fn cleanup(ptr: *mut ErlangException) {
    let _ = unsafe { Box::from_raw(ptr) };
}

#[export_name = "__lumen_builtin_yield"]
pub unsafe extern "C-unwind" fn process_yield() -> bool {
    scheduler::with_current(|scheduler| scheduler.process_yield())
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_builtin_exit"]
pub unsafe extern "C-unwind" fn process_exit(result: ErlangResult) {
    scheduler::with_current(|scheduler| {
        match result {
            ErlangResult::Ok(_) => {
                scheduler.current_process().exit_normal();
            }
            ErlangResult::Err(err) => {
                scheduler.current_process().exit_error(err);
            }
        }

        scheduler.process_yield()
    });
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_init"]
pub extern "C-unwind" fn bs_init() -> ErlangResult<NonNull<BitVec>, ()> {
    let buffer = Box::new(BitVec::new());
    ok!(unsafe { NonNull::new_unchecked(Box::into_raw(buffer)) })
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_push"]
pub extern "C-unwind" fn bs_push(
    mut bin: NonNull<BitVec>,
    spec: BinaryEntrySpecifier,
    value: OpaqueTerm,
    size: OpaqueTerm,
) -> ErlangResult<NonNull<BitVec>, NonNull<ErlangException>> {
    use half::f16;

    let buffer = unsafe { bin.as_mut() };
    match spec {
        BinaryEntrySpecifier::Integer {
            signed,
            unit,
            endianness,
        } => {
            // Size MUST be a non-negative integer
            let size: usize = match size.into() {
                Term::Int(sz) if sz >= 0 => sz.try_into().map_err(|_| badarg(Trace::capture()))?,
                _other => return err!(badarg(Trace::capture())),
            };
            let num_bits = size * (unit as usize);
            match value.into() {
                // Pushing with a size of zero has no effect
                Term::Int(_) | Term::BigInt(_) if num_bits == 0 => return ok!(bin),
                Term::Int(i) if signed => buffer.push_ap_number(i, num_bits, endianness),
                Term::Int(i) => buffer.push_ap_number(i as u64, num_bits, endianness),
                Term::BigInt(i) => buffer.push_ap_bigint(i.deref(), num_bits, signed, endianness),
                _ => return err!(badarg(Trace::capture())),
            }
            ok!(bin)
        }
        BinaryEntrySpecifier::Float { unit, endianness } => {
            // Size MUST be one of 16, 32, 64
            let size = match size.into() {
                Term::Int(sz) => {
                    let sz: usize = sz.try_into().map_err(|_| badarg(Trace::capture()))?;
                    match sz * unit as usize {
                        sz @ (16 | 32 | 64) => sz,
                        _ => return err!(badarg(Trace::capture())),
                    }
                }
                _ => return err!(badarg(Trace::capture())),
            };
            // Value can be any integer or float
            match value.into() {
                Term::Float(f) if size == 16 => {
                    buffer.push_number(f16::from_f64(f.as_f64()), endianness)
                }
                Term::Float(f) if size == 32 => buffer.push_number(f.as_f64() as f32, endianness),
                Term::Float(f) if size == 64 => buffer.push_number(f.as_f64(), endianness),
                Term::Int(i) if size == 16 => {
                    buffer.push_number(f16::from_f64(i as f64), endianness)
                }
                Term::Int(i) if size == 32 => buffer.push_number(i as f32, endianness),
                Term::Int(i) if size == 64 => buffer.push_number(i as f64, endianness),
                Term::BigInt(i) => match i.as_f64() {
                    Some(f) if size == 16 => buffer.push_number(f16::from_f64(f), endianness),
                    Some(f) if size == 32 => buffer.push_number(f as f32, endianness),
                    Some(f) if size == 64 => buffer.push_number(f, endianness),
                    _ => return err!(badarg(Trace::capture())),
                },
                _ => return err!(badarg(Trace::capture())),
            }
            ok!(bin)
        }
        BinaryEntrySpecifier::Binary { unit } => {
            // Size must be a non-negative integer, or None to represent pushing all of the source value
            // into the destination buffer
            let size: Option<usize> = match size.into() {
                Term::None => None,
                Term::Int(sz) if sz >= 0 => {
                    Some(sz.try_into().map_err(|_| badarg(Trace::capture()))?)
                }
                _ => return err!(badarg(Trace::capture())),
            };
            // Term must be a bitstring/binary
            let term: Term = value.into();
            match term.as_bitstring() {
                // Push all of a binary
                Some(bs) if unit == 8 && size.is_none() => {
                    // The source value must be a binary
                    if !bs.is_binary() {
                        return err!(badarg(Trace::capture()));
                    }
                    buffer.extend(bs.bytes());
                    ok!(bin)
                }
                // Push `size` bytes of the given bitstring
                Some(bs) if unit == 8 => {
                    let size = unsafe { size.unwrap_unchecked() };
                    // Selects precisely `size` bytes from the underlying data
                    // The value must be at least as large as the requested size
                    match bs.select_bytes(size) {
                        Ok(selection) => {
                            buffer.extend(selection.bytes());
                            ok!(bin)
                        }
                        _ => return err!(badarg(Trace::capture())),
                    }
                }
                // Push all bits of a bitstring
                Some(bs) if size.is_none() => {
                    // The source value may be either a binary or bitstring
                    if bs.is_binary() {
                        buffer.extend(bs.bytes());
                    } else {
                        buffer.extend(bs.bits());
                    }
                    ok!(bin)
                }
                // Push `size * unit` bits of the given bitstring
                Some(bs) => {
                    let size = unsafe { size.unwrap_unchecked() };
                    let bitsize = size * (unit as usize);
                    // Selects precisely `bitsize` bits from the underlying data
                    // The value must be at least as large as the requested size
                    match bs.select_bits(bitsize) {
                        Ok(selection) => {
                            buffer.extend(selection.bits());
                            ok!(bin)
                        }
                        _ => return err!(badarg(Trace::capture())),
                    }
                }
                _ => err!(badarg(Trace::capture())),
            }
        }
        BinaryEntrySpecifier::Utf8 => {
            let Term::Int(i) = value.into() else { return err!(badarg(Trace::capture())); };
            let Ok(codepoint) = i.try_into() else { return err!(badarg(Trace::capture())); };
            let Some(c) = char::from_u32(codepoint) else { return err!(badarg(Trace::capture())); };
            buffer.push_utf8(c);
            ok!(bin)
        }
        BinaryEntrySpecifier::Utf16 { endianness } => {
            let Term::Int(i) = value.into() else { return err!(badarg(Trace::capture())); };
            let Ok(codepoint) = i.try_into() else { return err!(badarg(Trace::capture())); };
            let Some(c) = char::from_u32(codepoint) else { return err!(badarg(Trace::capture())); };
            buffer.push_utf16(c, endianness);
            ok!(bin)
        }
        BinaryEntrySpecifier::Utf32 { endianness } => {
            let Term::Int(i) = value.into() else { return err!(badarg(Trace::capture())); };
            let Ok(codepoint) = i.try_into() else { return err!(badarg(Trace::capture())); };
            let Some(c) = char::from_u32(codepoint) else { return err!(badarg(Trace::capture())); };
            buffer.push_utf32(c, endianness);
            ok!(bin)
        }
    }
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_finish"]
pub extern "C-unwind" fn bs_finish(buffer: NonNull<BitVec>) -> ErlangResult<OpaqueTerm, ()> {
    use liblumen_alloc::rc::Rc;

    let buffer = unsafe { Box::from_raw(buffer.as_ptr()) };
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        match buffer.byte_size() {
            0 => {
                let bin = BinaryData::with_capacity_small(0, proc).unwrap();
                ok!(bin.into())
            }
            n if n <= 64 => {
                let mut bin = BinaryData::with_capacity_small(n, proc).unwrap();
                let bytes = unsafe { buffer.as_bytes_unchecked() };
                bin.copy_from_slice(&bytes[..n]);
                ok!(bin.into())
            }
            n => {
                let mut bin = BinaryData::with_capacity_large(n, proc).unwrap();
                let bytes = unsafe { buffer.as_bytes_unchecked() };
                {
                    // SAFETY: There can be no other references to this Rc yet,
                    // so we know this is safe
                    let b = unsafe { Rc::get_mut(&mut bin).unwrap_unchecked() };
                    b.copy_from_slice(&bytes[..n]);
                }
                ok!(bin.into())
            }
        }
    })
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_match_start"]
pub extern "C-unwind" fn bs_match_start(
    bin: OpaqueTerm,
) -> ErlangResult<NonNull<MatchContext>, NonNull<ErlangException>> {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        let boxed = MatchContext::new(bin, proc).unwrap();
        ok!(unsafe { NonNull::new_unchecked(GcBox::into_raw(boxed)) })
    })
}

#[export_name = "__lumen_bs_match"]
pub extern "C-unwind" fn bs_match(
    mut ctx: NonNull<MatchContext>,
    spec: BinaryEntrySpecifier,
    size: OpaqueTerm,
) -> MatchResult {
    use half::f16;

    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        let context = unsafe { ctx.as_mut() };
        let matcher = context.matcher();
        match spec {
            BinaryEntrySpecifier::Integer {
                signed,
                unit,
                endianness,
            } => {
                let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
                let size: usize = size.try_into().expect("invalid size");
                let bitsize = unit as usize * size;
                if bitsize == 0 {
                    MatchResult::ok(OpaqueTerm::ZERO, ctx)
                } else if bitsize > 52 {
                    match matcher.match_bigint(bitsize, signed, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => {
                            let big = GcBox::new_in(BigInteger(i), proc).unwrap();
                            MatchResult::ok(OpaqueTerm::from(big), ctx)
                        }
                    }
                } else if signed {
                    match matcher.match_ap_number::<i64, 8>(bitsize, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => MatchResult::ok(i.try_into().unwrap(), ctx),
                    }
                } else {
                    match matcher.match_ap_number::<u64, 8>(bitsize, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => MatchResult::ok((i as i64).try_into().unwrap(), ctx),
                    }
                }
            }
            BinaryEntrySpecifier::Float { unit, endianness } => {
                let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
                let size: usize = size.try_into().expect("invalid size");
                let bitsize = unit as usize * size;
                match bitsize {
                    0 => MatchResult::ok(0.0f64.into(), ctx),
                    16 => match matcher.match_number::<f16, 2>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(n) => {
                            let f: f64 = n.into();
                            MatchResult::ok(f.into(), ctx)
                        }
                    },
                    32 => match matcher.match_number::<f32, 4>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(n) => {
                            let f: f64 = n.into();
                            MatchResult::ok(f.into(), ctx)
                        }
                    },
                    64 => match matcher.match_number::<f64, 8>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(f) => MatchResult::ok(f.into(), ctx),
                    },
                    bitsize => panic!(
                        "invalid bitsize for floats, must be 16, 32 or 64, got {}",
                        bitsize
                    ),
                }
            }
            BinaryEntrySpecifier::Binary { unit } => {
                match size.into() {
                    Term::Int(size) => {
                        // Match `size * unit` bits of the binary/bitstring
                        let size: usize = size.try_into().expect("invalid size");
                        let bitsize = unit as usize * size;
                        match matcher.match_bits(bitsize) {
                            None => MatchResult::err(ctx),
                            Some(selection) => {
                                let bin = GcBox::new_in(
                                    BitSlice::from_selection(context.owner(), selection),
                                    proc,
                                )
                                .unwrap();
                                MatchResult::ok(OpaqueTerm::from(bin), ctx)
                            }
                        }
                    }
                    Term::None if unit == 8 => {
                        // Match the remaining bits, as long as those bits form a binary
                        match matcher.match_binary() {
                            Some(selection) => {
                                let bin = GcBox::new_in(
                                    BitSlice::from_selection(context.owner(), selection),
                                    proc,
                                )
                                .unwrap();
                                MatchResult::ok(OpaqueTerm::from(bin), ctx)
                            }
                            None => MatchResult::err(ctx),
                        }
                    }
                    Term::None => {
                        // Match the remaining bits
                        let selection = matcher.match_any();
                        let bin = GcBox::new_in(
                            BitSlice::from_selection(context.owner(), selection),
                            proc,
                        )
                        .unwrap();
                        MatchResult::ok(OpaqueTerm::from(bin), ctx)
                    }
                    other => panic!("expected an immediate integer or none, got {:#?}", &other),
                }
            }
            BinaryEntrySpecifier::Utf8 => match matcher.match_utf8() {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
            BinaryEntrySpecifier::Utf16 { endianness } => match matcher.match_utf16(endianness) {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
            BinaryEntrySpecifier::Utf32 { endianness } => match matcher.match_utf32(endianness) {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
        }
    })
}

#[export_name = "__lumen_bs_match_skip"]
pub extern "C-unwind" fn bs_match_skip(
    mut ctx: NonNull<MatchContext>,
    spec: BinaryEntrySpecifier,
    size: OpaqueTerm,
    value: u64,
) -> ErlangResult<NonNull<MatchContext>, NonNull<MatchContext>> {
    use half::f16;

    let context = unsafe { ctx.as_mut() };
    let matcher = context.matcher();
    match spec {
        BinaryEntrySpecifier::Integer {
            signed,
            unit,
            endianness,
        } => {
            let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
            let size: usize = size.try_into().expect("invalid size");
            let bitsize = unit as usize * size;
            if bitsize == 0 {
                ErlangResult::Ok(ctx)
            } else if bitsize > 64 {
                panic!("unexpected match size for bs.match.skip instruction, should have been 64 bits or less, got {}", bitsize);
            } else if signed {
                let expected = value as i64;
                match matcher.match_ap_number::<i64, 8>(bitsize, endianness) {
                    Some(i) if i == expected => ErlangResult::Ok(ctx),
                    _ => ErlangResult::Err(ctx),
                }
            } else {
                match matcher.match_ap_number::<u64, 8>(bitsize, endianness) {
                    Some(i) if i == value => ErlangResult::Ok(ctx),
                    _ => ErlangResult::Err(ctx),
                }
            }
        }
        BinaryEntrySpecifier::Float { unit, endianness } => {
            let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
            let size: usize = size.try_into().expect("invalid size");
            let bitsize = unit as usize * size;
            match bitsize {
                0 => ErlangResult::Ok(ctx),
                16 => match matcher.match_number::<f16, 2>(endianness) {
                    None => ErlangResult::Err(ctx),
                    Some(n) => {
                        let f: f64 = n.into();
                        if f.to_bits() == value {
                            ErlangResult::Ok(ctx)
                        } else {
                            ErlangResult::Err(ctx)
                        }
                    }
                },
                32 => match matcher.match_number::<f32, 4>(endianness) {
                    None => ErlangResult::Err(ctx),
                    Some(n) => {
                        let f: f64 = n.into();
                        if f.to_bits() == value {
                            ErlangResult::Ok(ctx)
                        } else {
                            ErlangResult::Err(ctx)
                        }
                    }
                },
                64 => match matcher.match_number::<f64, 8>(endianness) {
                    Some(f) if f.to_bits() == value => ErlangResult::Ok(ctx),
                    _ => ErlangResult::Err(ctx),
                },
                bitsize => panic!(
                    "invalid bitsize for floats, must be 16, 32 or 64, got {}",
                    bitsize
                ),
            }
        }
        spec @ BinaryEntrySpecifier::Binary { .. } => {
            panic!("unexpected match spec for bs.match.skip, got {:#?}", spec)
        }
        BinaryEntrySpecifier::Utf8 => match matcher.match_utf8() {
            Some(c) if c as u64 == value => ErlangResult::Ok(ctx),
            _ => ErlangResult::Err(ctx),
        },
        BinaryEntrySpecifier::Utf16 { endianness } => match matcher.match_utf16(endianness) {
            Some(c) if c as u64 == value => ErlangResult::Ok(ctx),
            _ => ErlangResult::Err(ctx),
        },
        BinaryEntrySpecifier::Utf32 { endianness } => match matcher.match_utf32(endianness) {
            Some(c) if c as u64 == value => ErlangResult::Ok(ctx),
            _ => ErlangResult::Err(ctx),
        },
    }
}

/// Tests the tail of the current match context matches the given size in bits
#[export_name = "__lumen_bs_test_tail"]
pub unsafe extern "C-unwind" fn bs_test_tail(ctx: NonNull<MatchContext>, size: usize) -> bool {
    ctx.as_ref().bits_remaining() != size
}

pub(self) fn badarg(trace: Arc<Trace>) -> NonNull<ErlangException> {
    crate::erlang::raise2(atoms::Badarg.into(), unsafe {
        NonNull::new_unchecked(Trace::into_raw(trace))
    })
    .unwrap_err()
}
