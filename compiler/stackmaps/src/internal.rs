///! This module contains a definition of the LLVM Stack Map structure
///! generated by the use of the `gc.statepoint` intrinsics. See the LLVM
///! [documentation](http://llvm.org/docs/StackMaps.html#stack-map-format)
///! for more details.
///!
///! Of particular note is this section of the docs:
///!
///!   "The runtime must be able to interpret the stack map record given only the ID,
///!    offset, and the order of the locations, which LLVM preserves."
///!
///! The phrase "order of the locations" here is interpreted to mean that not only
///! are callsite records corresponding to a function grouped together and ordered
///! from least to greatest offset, but that these callsite groups are also in the
///! same order as the array of function stack size records.
///!
///! This appears to be the case in LLVM, and these assumptions are necessary to
///! figure out what groups correspond to which functions to compute the return
///! adddresses; without resorting to hacks with the ID field that are unlikely to
///! be very reliable
///!
///! This is based on Kavon Favardin's [llvm-statepoint-utils](https://github.com/kavon/llvm-statepoint-utils)
///! tooling.
///!
///! ## StackMap Section/Structure Layout
///!
///! The following is the data layout in the StackMap section emitted by LLVM
///!
///!     Header {
///!       uint8  : Stack Map Version (current version is 3)
///!       uint8  : Reserved (expected to be 0)
///!       uint16 : Reserved (expected to be 0)
///!     }
///!     uint32 : NumFunctions
///!     uint32 : NumConstants
///!     uint32 : NumRecords
///!     StackSizeRecord[NumFunctions] {
///!       uint64 : Function Address
///!       uint64 : Stack Size
///!       uint64 : Record Count
///!     }
///!     Constants[NumConstants] {
///!       uint64 : LargeConstant
///!     }
///!     StackMapRecord[NumRecords] {
///!       uint64 : StatePoint/PatchPoint ID
///!       uint32 : Instruction Offset
///!       uint16 : Reserved (record flags)
///!       uint16 : NumLocations
///!       Location[NumLocations] {
///!         uint8  : Register | Direct | Indirect | Constant | ConstantIndex
///!         uint8  : Reserved (expected to be 0)
///!         uint16 : Location Size
///!         uint16 : Dwarf RegNum
///!         uint16 : Reserved (expected to be 0)
///!         int32  : Offset or SmallConstant
///!       }
///!       uint32 : Padding (only if required to align to 8 byte)
///!       uint16 : Padding
///!       uint16 : NumLiveOuts
///!       LiveOuts[NumLiveOuts]
///!         uint16 : Dwarf RegNum
///!         uint8  : Reserved
///!         uint8  : Size in Bytes
///!       }
///!       uint32 : Padding (only if required to align to 8 byte)
///!     }
///!

#[repr(C, packed)]
crate struct StackMapHeader {
    version: u8,
    _reserved1: u8,
    _reserved2: u16,
    num_functions: u32,
    num_constants: u32,
    num_records: u32,
}
impl StackMapHeader {
    #[inline(always)]
    pub fn version(&self) -> u8 {
        self.version
    }

    #[inline(always)]
    pub fn reserved1(&self) -> u8 {
        self._reserved1
    }

    #[inline]
    pub fn reserved2(&self) -> u16 {
        let reserved2 = core::ptr::addr_of!(self._reserved2);
        unsafe { core::ptr::read_unaligned(reserved2) }
    }

    #[inline(always)]
    pub fn num_functions(&self) -> u32 {
        self.num_functions
    }

    #[inline(always)]
    pub fn num_constants(&self) -> u32 {
        self.num_constants
    }

    #[inline(always)]
    pub fn num_records(&self) -> u32 {
        self.num_records
    }
}

#[repr(C, packed)]
pub struct FunctionInfo {
    pub address: usize,
    pub stack_size: usize,
    // See https://reviews.llvm.org/D23487
    crate num_callsites: usize,
}
impl FunctionInfo {
    /// This function constructs an Iterator over the call sites for
    /// this function. It is necessary to provide the pointer to the
    /// first CallSiteHeader for this function so we know where to start
    /// iterating from.
    ///
    /// This isn't ideal, but due to how the Stack Map region is laid out
    /// in memory, we don't have an alternative.
    #[inline]
    crate fn callsites(
        &self,
        base: *const CallSiteHeader,
    ) -> impl Iterator<Item = &'static CallSiteHeader> {
        assert_ne!(base, core::ptr::null());
        CallSiteIterator {
            current: base,
            pos: 0,
            num_callsites: self.num_callsites as usize,
        }
    }
}

#[repr(C, packed)]
crate struct CallSiteHeader {
    crate id: usize,
    // This offset is from the function entry
    crate code_offset: u32,
    crate flags: u16,
    crate num_locations: u16,
}

/// An iterator over the CallSiteHeaders contained in the StackMap
struct CallSiteIterator {
    current: *const CallSiteHeader,
    num_callsites: usize,
    pos: usize,
}
impl Iterator for CallSiteIterator {
    type Item = &'static CallSiteHeader;

    fn next(&mut self) -> Option<Self::Item> {
        if self.pos >= self.num_callsites {
            return None;
        }

        let current = unsafe { &*self.current };

        // Calculate the pointer to the start of the next header
        let next_ptr = unsafe {
            // Skip over locations
            let locations_base = self.current.add(1) as *const ValueLocation;
            let locations_end = locations_base.add(current.num_locations as usize) as *const u8;

            // Realign pointer at the end of the locations to 8 byte alignment
            let offset = locations_end.align_offset(8);
            assert_ne!(offset, usize::MAX);
            let aligned = locations_end.add(offset);

            // Skip over liveouts
            let liveout_base = aligned as *const LiveOutHeader;
            let liveout_header = &*liveout_base;
            let liveout_locs_base = liveout_base.add(1) as *const LiveOutLocation;
            let liveout_locs_end = liveout_locs_base.add(liveout_header.num_liveouts as usize);

            // Realign pointer again, leaving us at the beginning
            // of the next CallSiteHeader
            let offset = liveout_locs_end.align_offset(8);
            assert_ne!(offset, usize::MAX);
            liveout_locs_end.add(offset) as *const CallSiteHeader
        };

        self.current = next_ptr;
        self.pos += 1;

        Some(unsafe { &*next_ptr })
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        let remaining = self.num_callsites - self.pos;
        (remaining, Some(remaining))
    }
}
impl core::iter::FusedIterator for CallSiteIterator {}
impl ExactSizeIterator for CallSiteIterator {}

/// This enum describes the type of location, which is used
/// to determine how to interpret `reg_num` and `offset` fields
/// in `ValueLocation`.
///
/// Encoding | Type | Value | Description
/// --------------------------------------
/// 0x1 | Register   | Reg               | Value in a register
/// 0x2 | Direct     | Reg + Offset      | Frame index value
/// 0x3 | Indirect   | [Reg + Offset]    | Spilled value
/// 0x4 | Constant   | Offset            | Small constant
/// 0x5 | ConstIndex | Constants[Offset] | Large constant
#[allow(dead_code)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
crate enum LocationKind {
    Register = 1,
    Direct,
    Indirect,
    Constant,
    ConstantIndex,
}

#[repr(C, packed)]
crate struct ValueLocation {
    crate kind: LocationKind,
    // Expected to be 0
    crate flags: u8,
    crate location_size: u16,
    // DWARF RegNum
    crate reg_num: u16,
    // Expected to be 0
    crate _reserved: u16,
    // Either an offset, or a "small constant"
    crate offset: i32,
}
impl ValueLocation {
    #[inline(always)]
    crate fn is_base_pointer(&self, other: &Self) -> bool {
        self == other
    }

    #[inline(always)]
    crate fn is_indirect(&self) -> bool {
        self.kind == LocationKind::Indirect
    }

    // The assumption is that the value_location given to this function
    // is known to be of the offset type, and now we need to parse the
    // offset. Offsets are given relative to a register value,
    // and since it might be either the frame pointer or stack pointer.
    //
    // This function will always return the offset relative to the stack ptr.
    crate fn convert_offset(&self, frame_size: usize) -> i32 {
        assert_eq!(self.kind, LocationKind::Indirect);

        match self.reg_num {
            // Offset is relative to stack pointer
            7 => {
                assert!(self.offset >= 0, "unexpected offset");
                self.offset
            }
            // Offset is relative to base pointer
            // NOTE: As of yet, statepoints haven't been seen to generate such offsets
            6 => {
                assert!(self.offset <= 0, "unexpected offset");
                frame_size as i32 + self.offset
            }
            _ => panic!("value location offset is not relative to some part of the frame"),
        }
    }
}
impl PartialEq for ValueLocation {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.kind == other.kind && self.offset == other.offset
    }
}

#[repr(C, packed)]
crate struct LiveOutHeader {
    crate _padding: u16,
    crate num_liveouts: u16,
}

/// A "liveout" location are registers that
/// are live across the stackmap and therefore must
/// be saved by the runtime. This is primarily of relevance
/// to the PatchPoint intrinsics.
#[repr(C, packed)]
crate struct LiveOutLocation {
    // DWARF RegNum
    crate reg_num: u16,
    crate flags: u8,
    crate size_in_bytes: u8,
}
