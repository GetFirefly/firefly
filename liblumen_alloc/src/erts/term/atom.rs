use core::cmp;
use core::fmt::{self, Debug, Display, Write};
use core::mem;

use core::ptr;
use core::slice;
use core::str::{self, Utf8Error};

use std::ffi::CStr;

use hashbrown::HashMap;
use lazy_static::lazy_static;
use thiserror::Error;

use liblumen_arena::DroplessArena;

use liblumen_core::alloc::prelude::*;
use liblumen_core::locks::RwLock;

use super::prelude::{Term, TypeError, TypedTerm};

/// The maximum number of atoms allowed
pub const MAX_ATOMS: usize = super::arch::MAX_ATOM_ID - 1;

/// The maximum length of an atom (255)
pub const MAX_ATOM_LENGTH: usize = u16::max_value() as usize;

lazy_static! {
    /// The atom table used by the runtime system
    static ref ATOMS: RwLock<AtomTable> = Default::default();
}

/// Performs one-time initialization of the atom table at program start, using the
/// array of constant atom values present in the compiled program.
///
/// It is expected that this will be called by code generated by the compiler, during the
/// earliest phase of startup, to ensure that nothing has tried to use the atom table yet.
#[no_mangle]
pub unsafe extern "C-unwind" fn InitializeLumenAtomTable(
    start: *const std::os::raw::c_char,
    end: *const std::os::raw::c_char,
) -> bool {
    if start == end {
        return true;
    }
    if start.is_null() || end.is_null() {
        return false;
    }
    let mut default_table = ATOMS.write();
    let mut next = start;
    loop {
        if next >= end {
            break;
        }
        let cs = CStr::from_ptr::<'static>(next);
        let name = cs.to_str().unwrap_or_else(|error| {
            panic!(
                "unable to construct atom from cstr `{}` due to invalid utf-8: {:?}",
                cs.to_string_lossy(),
                error,
            )
        });
        if let Err(error) = default_table.get_id_or_insert_static(name) {
            panic!("unable to insert atom `{}` in table: {:?}", name, error);
        }
        next = cs.to_bytes_with_nul().as_ptr_range().end as *const std::os::raw::c_char;
    }
    true
}

#[export_name = "__lumen_builtin_atom_from_cstr"]
pub unsafe extern "C-unwind" fn atom_from_cstr(ptr: *const std::os::raw::c_char) -> Term {
    let atom = Atom::from_raw_cstr(ptr);
    atom.as_term()
}

pub fn dump_atoms() {
    let table = ATOMS.read();
    table.dump();
}

/// An interned string, represented in memory as a integer ID.
///
/// This struct is simply a transparent wrapper around the ID.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Atom(usize);
impl Atom {
    pub const SIZE_IN_WORDS: usize = 1;

    pub const TRUE: Self = Self(1);
    pub const FALSE: Self = Self(0);
    pub const ERROR: Self = Self(46);
    pub const THROW: Self = Self(58);
    pub const EXIT: Self = Self(59);

    /// Gets the identifier associated with this atom
    #[inline(always)]
    pub fn id(&self) -> usize {
        self.0
    }

    /// Returns the string representation of this atom
    #[inline]
    pub fn name(&self) -> &'static str {
        ATOMS.read().get_name(self.0).unwrap()
    }

    /// Returns true if this atom is a boolean value
    #[inline]
    pub fn is_boolean(&self) -> bool {
        // NOTE: This relies on the fact that the atom table is
        // initialized such that true/false are at indices 1 and 0
        self.0 < 2
    }

    /// Creates a new atom from a slice of bytes interpreted as Latin-1.
    ///
    /// Returns `Err` if the atom name is invalid or the table overflows
    #[inline]
    pub fn try_from_latin1_bytes(name: &[u8]) -> Result<Self, AtomError> {
        Self::try_from_str(str::from_utf8(name)?)
    }

    /// Like `try_from_latin1_bytes`, but requires that the atom already exists
    ///
    /// Returns `Err` if the atom does not exist
    #[inline]
    pub fn try_from_latin1_bytes_existing(name: &[u8]) -> Result<Self, AtomError> {
        Self::try_from_str_existing(str::from_utf8(name)?)
    }

    /// For convenience, this function takes a `str`, creates an atom
    /// from it, and immediately encodes the resulting `Atom` as a `Term`
    ///
    /// Panics if the name is invalid, the table overflows, or term encoding fails
    #[inline]
    pub fn str_to_term<S: AsRef<str>>(s: S) -> Term {
        use crate::erts::term::prelude::Encode;

        Self::from_str(s).encode().unwrap()
    }

    /// Convenience function for encoding atoms as terms
    #[inline(always)]
    pub fn as_term(&self) -> Term {
        use crate::erts::term::prelude::Encode;

        self.encode().unwrap()
    }

    /// This function is intended for internal use only.
    ///
    /// # Safety
    ///
    /// You must ensure the following is true of the given pointer:
    ///
    /// * It points to a null-terminated C-string
    /// * The content of the string is valid UTF-8 data
    /// * The pointer is valid for the entire lifetime of the program
    ///
    /// If any of these constraints are violated, the behavior is undefined.
    #[inline]
    pub(crate) unsafe fn from_raw_cstr(ptr: *const std::os::raw::c_char) -> Self {
        let cs = CStr::from_ptr::<'static>(ptr);
        let name = cs.to_str().unwrap_or_else(|error| {
            panic!(
                "unable to construct atom from cstr `{}` due to invalid utf-8: {:?}",
                cs.to_string_lossy(),
                error,
            )
        });
        Self(ATOMS.write().get_id_or_insert_static(name).unwrap())
    }

    /// Creates a new atom from a `str`.
    ///
    /// Panics if the name is invalid or the table overflows
    #[inline]
    pub fn from_str<S: AsRef<str>>(s: S) -> Self {
        Self::try_from_str(s).unwrap()
    }

    /// Creates a new atom from a `str`.
    ///
    /// Returns `Err` if the atom name is invalid or the table overflows
    #[inline]
    pub fn try_from_str<S: AsRef<str>>(s: S) -> Result<Self, AtomError> {
        let name = s.as_ref();
        Self::validate(name)?;
        if let Some(id) = ATOMS.read().get_id(name) {
            return Ok(Atom(id));
        }
        let id = ATOMS.write().get_id_or_insert(name)?;
        Ok(Self(id))
    }

    /// Creates a new atom from a `str`, but only if the atom already exists
    ///
    /// Returns `Err` if the atom does not exist
    #[inline]
    pub fn try_from_str_existing<S: AsRef<str>>(s: S) -> Result<Self, AtomError> {
        let name = s.as_ref();
        Self::validate(name)?;
        if let Some(id) = ATOMS.read().get_id(name) {
            return Ok(Self(id));
        }
        Err(AtomError::NonExistent.into())
    }

    /// Creates a new atom from its id.
    ///
    /// # Safety
    ///
    /// This function is unsafe because creating an `Atom`
    /// with an id that doesn't exist will result in undefined
    /// behavior. This should only be used by `Term` when converting
    /// to `TypedTerm`
    /// ```
    #[inline]
    pub const unsafe fn from_id(id: usize) -> Self {
        Self(id)
    }

    // See https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L193-L212
    fn needs_quotes(&self) -> bool {
        let mut chars = self.name().chars();

        match chars.next() {
            Some(first_char) => {
                // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L198-L199
                // -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L98
                !first_char.is_ascii_lowercase() || {
                    // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L201-L200
                    // -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L102
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L91
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L91
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L99
                    chars.any(|c| (!c.is_ascii_alphanumeric() && c != '_'))
                }
            }
            // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L187-L190
            None => true,
        }
    }

    fn validate(name: &str) -> Result<(), AtomError> {
        let len = name.len();
        if len > MAX_ATOM_LENGTH {
            return Err(AtomError::InvalidLength(len));
        }
        Ok(())
    }
}

impl PartialEq<bool> for Atom {
    fn eq(&self, b: &bool) -> bool {
        // NOTE: This relies on the fact that we initialize the
        // atom table with 'false' at index 0, and 'true' at
        // index 1; and that Rust will convert bools to integers
        // such at false is 0 and true is 1
        let id = self.id();
        let b = *b;
        id == (b as usize)
    }
}
impl PartialEq<&str> for Atom {
    fn eq(&self, s: &&str) -> bool {
        self.name() == *s
    }
}

impl From<bool> for Atom {
    #[inline]
    fn from(b: bool) -> Self {
        // NOTE: We can make these assumptions because the AtomTable
        // is initialized in a deterministic way - it is critical that
        // if the initialization changes that these values get updated
        if b {
            Atom::TRUE
        } else {
            Atom::FALSE
        }
    }
}

impl Display for Atom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let needs_quotes = self.needs_quotes();

        if needs_quotes {
            f.write_char('\'')?;
        }

        for c in self.name().chars() {
            // https://github.com/erlang/otp/blob/dbf25321bdfdc3f4aae422b8ba2c0f31429eba61/erts/emulator/beam/erl_printf_term.c#L215-L232
            match c {
                '\'' => f.write_str("\\'")?,
                '\\' => f.write_str("\\\\")?,
                '\n' => f.write_str("\\n")?,
                '\u{C}' => f.write_str("\\f")?,
                '\t' => f.write_str("\\t")?,
                '\r' => f.write_str("\\r")?,
                '\u{8}' => f.write_str("\\b")?,
                '\u{B}' => f.write_str("\\v")?,
                _ if c.is_control() => write!(f, "\\{:o}", c as u8)?,
                _ => f.write_char(c)?,
            }
        }

        if needs_quotes {
            f.write_char('\'')?;
        }

        Ok(())
    }
}

impl Debug for Atom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if let Some(name) = ATOMS.read().get_name(self.0) {
            f.write_str(":\"")?;
            name.chars()
                .flat_map(char::escape_default)
                .try_for_each(|c| f.write_char(c))?;
            f.write_char('\"')
        } else {
            f.debug_tuple("Atom").field(&self.0).finish()
        }
    }
}

impl PartialOrd for Atom {
    #[inline]
    fn partial_cmp(&self, other: &Atom) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl Ord for Atom {
    #[inline]
    fn cmp(&self, other: &Atom) -> cmp::Ordering {
        use cmp::Ordering;

        if self.0 == other.0 {
            return Ordering::Equal;
        }
        self.name().cmp(other.name())
    }
}

impl TryFrom<TypedTerm> for Atom {
    type Error = TypeError;

    fn try_from(typed_term: TypedTerm) -> Result<Self, Self::Error> {
        match typed_term {
            TypedTerm::Atom(atom) => Ok(atom),
            _ => Err(TypeError),
        }
    }
}

/// Produced by operations which create atoms
#[derive(Error, Debug)]
pub enum AtomError {
    #[error("exceeded system limit: maximum number of atoms ({})", MAX_ATOMS)]
    TooManyAtoms,
    #[error("invalid atom, length is {}, maximum length is {}", .0, MAX_ATOM_LENGTH)]
    InvalidLength(usize),
    #[error("tried to convert to an atom that doesn't exist")]
    NonExistent,
    #[error("invalid utf-8 bytes: {}", .0)]
    InvalidString(#[from] Utf8Error),
}
impl Eq for AtomError {}
impl PartialEq for AtomError {
    fn eq(&self, other: &AtomError) -> bool {
        mem::discriminant(self) == mem::discriminant(other)
    }
}

struct AtomTable {
    next_id: usize,
    ids: HashMap<&'static str, usize>,
    names: HashMap<usize, &'static str>,
    arena: DroplessArena,
}
impl AtomTable {
    const DEFAULT_ATOMS: &'static [&'static str] = &["false", "true"];

    fn new(names: &[&'static str]) -> Self {
        let len = names.len();
        let mut table = Self {
            next_id: 0,
            ids: HashMap::with_capacity(len),
            names: HashMap::with_capacity(len),
            arena: DroplessArena::default(),
        };
        let interned_names = &mut table.names;
        let next_id = &mut table.next_id;
        for name in names {
            table.ids.entry(name).or_insert_with(|| {
                let id = *next_id;
                *next_id += 1;
                interned_names.insert(id, name);
                id
            });
        }
        table
    }

    fn get_id(&self, name: &str) -> Option<usize> {
        self.ids.get(name).cloned()
    }

    fn get_name(&self, id: usize) -> Option<&'static str> {
        self.names.get(&id).cloned()
    }

    fn get_id_or_insert(&mut self, name: &str) -> Result<usize, AtomError> {
        match self.get_id(name) {
            Some(existing_id) => Ok(existing_id),
            None => unsafe { self.insert(name) },
        }
    }

    // SAFETY: See insert_static for the safety constraints
    unsafe fn get_id_or_insert_static(&mut self, name: &'static str) -> Result<usize, AtomError> {
        match self.get_id(name) {
            Some(existing_id) => Ok(existing_id),
            None => self.insert_static(name),
        }
    }

    // SAFETY: You must ensure two things about the string passed to this function:
    //
    // * The string reference MUST have been derived from a CStr pointer. This is because
    // we assume that the pointer the reference is based on can be safely treated as a pointer
    // to a null-terminated string. If it can't, bad things will happen.
    // * The string you pass to this function MUST be truly valid for static lifetime, or
    // the behavior is undefined.
    //
    // This is intended to avoid wasting space on atoms which are already
    // stored in the read-only atom section constructed by the linker. This data is always valid for
    // the static lifetime, and so we can construct `&'static str` from them safely.
    unsafe fn insert_static(&mut self, name: &'static str) -> Result<usize, AtomError> {
        let id = self.next_id;
        self.next_id += 1;
        if id > MAX_ATOMS {
            return Err(AtomError::TooManyAtoms);
        }

        self.ids.insert(name, id);
        self.names.insert(id, name);

        Ok(id)
    }

    // This function is used to insert new atoms in the table during runtime
    // SAFETY: `name` must have been checked as not existing while holding the current mutable reference.
    unsafe fn insert(&mut self, name: &str) -> Result<usize, AtomError> {
        let id = self.next_id;
        self.next_id += 1;
        if id > MAX_ATOMS {
            return Err(AtomError::TooManyAtoms);
        }

        let size = name.len();

        let s = {
            // Copy string into arena, add an extra byte to ensure the string is null-terminated
            let layout = Layout::from_size_align_unchecked(size + 1, mem::align_of::<u8>());
            let ptr = self.arena.alloc_raw(layout);
            if size > 0 {
                ptr::copy_nonoverlapping(name as *const _ as *const u8, ptr, size);
                // Ensure the final byte is null
                ptr.add(size).write(0);
            } else {
                // Ensure the final byte is null
                ptr.write(0);
            }
            let bytes = slice::from_raw_parts(ptr, size);
            str::from_utf8_unchecked(bytes)
        };

        // Push into id map
        self.ids.insert(s, id);
        self.names.insert(id, s);

        Ok(id)
    }

    fn dump(&self) {
        for (id, name) in self.names.iter() {
            println!("atom(id = {}, value = '{}')", *id, name);
        }
    }
}
impl Default for AtomTable {
    fn default() -> Self {
        AtomTable::new(Self::DEFAULT_ATOMS)
    }
}

/// This is safe to implement because the only usage is the ATOMS static, which is wrapped in an
/// `RwLock`, but it is _not_ `Sync` in general, so don't try and use it as such in other situations
unsafe impl Sync for AtomTable {}

#[derive(Debug, Error)]
#[error("atom ({0}) is not supported")]
pub struct TryAtomFromTermError(pub &'static str);
