use alloc::boxed::Box;
use alloc::sync::Arc;

use firefly_system::sync::OnceLock;

use crate::process::signals::SignalEntry;
use crate::term::OpaqueTerm;

/// System messages are enqueued in a special system message queue which is processed
/// by a dedicated thread separate from the rest of the runtime. It handles tasks
/// which are critical to core funtime functionality that cannot otherwise be delegated
/// to processes started by `kernel`.
pub enum SystemMessage {
    /// Logger messages generated by the runtime are handled by the system dispatcher by
    /// relaying them to the appropriate logger process. This offloads some of the work
    /// and bookkeeping related to logging to the dispatcher and keeps the overhead of
    /// logging low.
    ErrorLogger { message: Box<SignalEntry> },
}

pub trait SystemDispatcher: Send + Sync {
    /// Sets the process which will receive logging messages generated by the runtime system
    ///
    /// If set to `OpaqueTerm::NONE`, all logging messages are dropped.
    ///
    /// If set to an atom value, the name must be `logger`. This will send logging
    /// messages to whatever process has that registered name. This is the default value
    /// of the logger.
    ///
    /// If set to a pid value, the logging messages will be sent to the
    /// specified process. However, the process _must_ be a local process, and if the process
    /// dies, the logger will be reset to the default (i.e. the process registered to `logger`).
    fn set_system_logger(&self, logger: OpaqueTerm) -> OpaqueTerm;
    /// Enqueues a message in the system message queue
    fn enqueue(&self, message: SystemMessage);
}

static SYSTEM_DISPATCHER: OnceLock<Arc<dyn SystemDispatcher>> = OnceLock::new();

/// Get a reference to the current system dispatcher instance
#[inline]
pub fn system_dispatcher() -> Arc<dyn SystemDispatcher> {
    SYSTEM_DISPATCHER.get().unwrap().clone()
}

/// Install the given global system dispatcher
///
/// This function may only be called once when the system is started, and must be
/// called before any uses of the logger occur.
#[inline]
pub fn install_system_dispatcher(msgr: Arc<dyn SystemDispatcher>) {
    if let Err(_) = SYSTEM_DISPATCHER.set(msgr) {
        panic!("tried to install a system dispatcher twice!");
    }
}

/// Set the system logger to `logger`
///
/// The given logger must be one of:
///
/// * OpaqueTerm::NONE
/// * The registered name `logger`
/// * A pid value corresponding to a local process
#[inline]
pub fn set_system_logger(logger: OpaqueTerm) -> OpaqueTerm {
    SYSTEM_DISPATCHER.get().unwrap().set_system_logger(logger)
}

/// Enqueues `message` in the system message queue
#[inline]
pub fn send_system_message(message: SystemMessage) {
    SYSTEM_DISPATCHER.get().unwrap().enqueue(message)
}
