#include "llvm/Support/Casting.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/StandardOps/IR/Ops.h"
#include "mlir/Analysis/Liveness.h"
#include "mlir/IR/Dominance.h"

#include "lumen/EIR/Builder/Passes.h"
#include "lumen/EIR/IR/EIRDialect.h"
#include "lumen/EIR/IR/EIROps.h"
#include "lumen/EIR/IR/EIRTypes.h"

using ::mlir::Block;
using ::mlir::BlockArgument;
using ::mlir::DialectRegistry;
using ::mlir::Location;
using ::mlir::OpBuilder;
using ::mlir::Operation;
using ::mlir::OperationPass;
using ::mlir::OpOperand;
using ::mlir::PassWrapper;
using ::mlir::Value;
using ::mlir::DominanceInfo;
using ::mlir::Liveness;
using ::mlir::LivenessBlockInfo;
using ::mlir::PostDominanceInfo;

using ::llvm::cast;
using ::llvm::dyn_cast_or_null;
using ::llvm::isa;
using ::llvm::SmallPtrSet;

namespace {

using namespace ::lumen::eir;

template <typename DominatorT>
Block *findCommonDominator(Value, const SmallPtrSet<Value, 16> &, const DominatorT &);

void fixDominance(DominanceInfo &, PostDominanceInfo &, Liveness &, Value, Operation *);


/// HACK(pauls)
///
/// This rewrite pattern/canonicalization is used to handle the possibility
/// that IR generated by lowering from EIR has scheduled operations with
/// invalid dominance, i.e. operations were lowered too close to a use and
/// it is expected that the operation is available in a sibling scope.
///
/// Until EIR handles statically scheduling operations in a way that makes
/// this unnecessary, this canonicalization pattern performs dominance analysis
/// and fixes up the IR so that there are no operations with uses that are not
/// dominated by the definition
struct ScheduleOperationsPass
    : public PassWrapper<ScheduleOperationsPass, OperationPass<FuncOp>> {
    void getDependentDialects(DialectRegistry &registry) const override {
        registry.insert<mlir::StandardOpsDialect, mlir::LLVM::LLVMDialect,
                        lumen::eir::eirDialect>();
    }

    void runOnOperation() override {
        FuncOp funcOp = getOperation();
        if (funcOp.isExternal()) return;

        OpBuilder builder(funcOp.getParentOfType<ModuleOp>());
        
        DominanceInfo domInfo(funcOp.getOperation());
        PostDominanceInfo postDomInfo(funcOp.getOperation());
        Liveness liveness(funcOp.getOperation());


        // Verify the dominance of each of the held operations.
        for (Block &block : funcOp.getBody()) {
          // Dominance is only meaningful inside reachable blocks.
          if (domInfo.isReachableFromEntry(&block)) {
            for (Operation &op : block) {
              // Check that operands properly dominate this use.
              for (unsigned operandNo = 0, e = op.getNumOperands(); operandNo != e;
                   ++operandNo) {
                 auto operand = op.getOperand(operandNo);
                 if (domInfo.properlyDominates(operand, &op)) continue;
                 // We've found an operand whose definition does not dominate this
                 // use. We need to fix this by moving its defining operation to
                 // a common dominating block, or if there isn't one, clone the
                 // definition here.
                 //
                 // When such dominance violations are found, there is a high
                 // probability that other uses of that operation may also not be
                 // dominated by the definition, so when we encounter these, we fix
                 // all uses in one go.
                 if (auto *useOp = operand.getDefiningOp()) {
                   fixDominance(domInfo, postDomInfo, liveness, operand, useOp);
                 } else {
                   // There is nothing we can do here, we don't have a definition
                   // to operate on, which doesn't make sense, but without one there
                   // is nothing for us to try and fix, its just broken.
                   auto diag = op.emitError("operand #")
                                << operandNo
                                << " does not dominate this use and lacks a "
                                   "definition that can be rescheduled";
                   signalPassFailure();
                   return;
                 }
              }
            }
          }
        }

        return;
    }
};


/// Finds a common dominator for the given value while taking the positions
/// of the values in the value set into account. It supports dominator and
/// post-dominator analyses via template arguments.
template <typename DominatorT>
Block *findCommonDominator(Value value, const SmallPtrSet<Value, 16> &values,
                           const DominatorT &doms) {
    // Start with the current block the value is defined in.
    Block *dom = value.getParentBlock();
    // Iterate over all aliases and their uses to find a safe placement block
    // according to the given dominator information.
    for (Value childValue : values) {
      for (Operation *user : childValue.getUsers()) {
        // Move upwards in the dominator tree to find an appropriate
        // dominator block that takes the current use into account.
        dom = doms.findNearestCommonDominator(dom, user->getBlock());
      }
    }
    return dom;
}

void fixDominance(DominanceInfo &domInfo, PostDominanceInfo &postDomInfo,
                  Liveness &liveness, Value result, Operation *op) {
    // Get all of the operands for `op`, since these operands are important to it
    auto operands = op->getOperands();
    Block *dominator;
    
    if (operands.size() < 1) {
      SmallPtrSet<Value, 16> uses;
      for (auto &use : op->getUses()) uses.insert(use.get());
        dominator = findCommonDominator(result, uses, domInfo);
    } else {
      // If this node has dependencies, check all dependent nodes with respect
      // to a common post dominator in which all values are available.
      SmallPtrSet<Value, 16> dependencies(++operands.begin(), operands.end());
      dominator =
        findCommonDominator(*operands.begin(), dependencies, postDomInfo);
    }
    
    // We've now calculated the block to place the operation definition in.
    // Now we need to get liveness information for that block to ensure
    // that we place the definition before its first use in that block.
    const LivenessBlockInfo *livenessInfo = liveness.getLiveness(dominator);
    Operation *startOperation = livenessInfo->getStartOperation(result);
    // Check whether the start operation lies in the desired placement block.
    // If not, we will use the terminator as this is the last operation in
    // this block.
    if (startOperation->getBlock() != dominator)
      startOperation = dominator->getTerminator();
    
    // Move the def in front of the start operation.
    op->moveBefore(startOperation);
}

}  // namespace

namespace lumen {
namespace eir {
std::unique_ptr<mlir::Pass> createScheduleOperationsPass() {
    return std::make_unique<ScheduleOperationsPass>();
}
}  // namespace eir
}  // namespace lumen
