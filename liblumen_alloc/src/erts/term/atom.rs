use core::cmp;
use core::convert::TryFrom;
use core::fmt::{self, Debug, Display, Write};
use core::mem;

use core::ptr;
use core::slice;
use core::str::{self, Utf8Error};

use std::os::raw::c_uint;

use hashbrown::HashMap;
use lazy_static::lazy_static;
use thiserror::Error;

use liblumen_arena::DroplessArena;

use liblumen_core::atoms::ConstantAtom;
use liblumen_core::locks::RwLock;

use super::prelude::{Term, TypeError, TypedTerm};

/// The maximum number of atoms allowed
pub const MAX_ATOMS: usize = super::arch::MAX_ATOM_ID - 1;

/// The maximum length of an atom (255)
pub const MAX_ATOM_LENGTH: usize = u16::max_value() as usize;

lazy_static! {
    /// The atom table used by the runtime system
    static ref ATOMS: RwLock<AtomTable> = Default::default();
}

/// Performs one-time initialization of the atom table at program start, using the
/// array of constant atom values present in the compiled program.
///
/// It is expected that this will be called by code generated by the compiler, during the
/// earliest phase of startup, to ensure that nothing has tried to use the atom table yet.
#[no_mangle]
pub unsafe extern "C" fn InitializeLumenAtomTable(table: *const ConstantAtom, len: c_uint) -> bool {
    let len = len as usize;
    if len == 0 {
        return true;
    }
    if table.is_null() {
        return false;
    }
    let raw_table = slice::from_raw_parts::<'static>(table, len);
    let mut default_table = ATOMS.write();
    if let Err(err) = default_table.from_raw(raw_table) {
        panic!("{}", err);
    } else {
        true
    }
}

pub fn dump_atoms() {
    let table = ATOMS.read();
    table.dump();
}

/// An interned string, represented in memory as a integer ID.
///
/// This struct is simply a transparent wrapper around the ID.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Atom(usize);
impl Atom {
    pub const SIZE_IN_WORDS: usize = 1;

    pub const TRUE: Self = Self(1);
    pub const FALSE: Self = Self(0);
    pub const ERROR: Self = Self(46);
    pub const THROW: Self = Self(58);
    pub const EXIT: Self = Self(59);

    /// Gets the identifier associated with this atom
    #[inline(always)]
    pub fn id(&self) -> usize {
        self.0
    }

    /// Returns the string representation of this atom
    #[inline]
    pub fn name(&self) -> &'static str {
        ATOMS.read().get_name(self.0).unwrap()
    }

    /// Returns true if this atom is a boolean value
    #[inline]
    pub fn is_boolean(&self) -> bool {
        // NOTE: This relies on the fact that the atom table is
        // initialized such that true/false are at indices 1 and 0
        self.0 < 2
    }

    /// Creates a new atom from a slice of bytes interpreted as Latin-1.
    ///
    /// Returns `Err` if the atom name is invalid or the table overflows
    #[inline]
    pub fn try_from_latin1_bytes(name: &[u8]) -> Result<Self, AtomError> {
        Self::try_from_str(str::from_utf8(name)?)
    }

    /// Like `try_from_latin1_bytes`, but requires that the atom already exists
    ///
    /// Returns `Err` if the atom does not exist
    #[inline]
    pub fn try_from_latin1_bytes_existing(name: &[u8]) -> Result<Self, AtomError> {
        Self::try_from_str_existing(str::from_utf8(name)?)
    }

    /// For convenience, this function takes a `str`, creates an atom
    /// from it, and immediately encodes the resulting `Atom` as a `Term`
    ///
    /// Panics if the name is invalid, the table overflows, or term encoding fails
    #[inline]
    pub fn str_to_term<S: AsRef<str>>(s: S) -> Term {
        use crate::erts::term::prelude::Encode;

        Self::from_str(s).encode().unwrap()
    }

    /// Convenience function for encoding atoms as terms
    #[inline(always)]
    pub fn as_term(&self) -> Term {
        use crate::erts::term::prelude::Encode;

        self.encode().unwrap()
    }

    /// Creates a new atom from a `str`.
    ///
    /// Panics if the name is invalid or the table overflows
    #[inline]
    pub fn from_str<S: AsRef<str>>(s: S) -> Self {
        Self::try_from_str(s).unwrap()
    }

    /// Creates a new atom from a `str`.
    ///
    /// Returns `Err` if the atom name is invalid or the table overflows
    #[inline]
    pub fn try_from_str<S: AsRef<str>>(s: S) -> Result<Self, AtomError> {
        let name = s.as_ref();
        Self::validate(name)?;
        if let Some(id) = ATOMS.read().get_id(name) {
            return Ok(Atom(id));
        }
        let id = ATOMS.write().get_id_or_insert(name)?;
        Ok(Atom(id))
    }

    /// Creates a new atom from a `str`, but only if the atom already exists
    ///
    /// Returns `Err` if the atom does not exist
    #[inline]
    pub fn try_from_str_existing<S: AsRef<str>>(s: S) -> Result<Self, AtomError> {
        let name = s.as_ref();
        Self::validate(name)?;
        if let Some(id) = ATOMS.read().get_id(name) {
            return Ok(Atom(id));
        }
        Err(AtomError::NonExistent.into())
    }

    /// Creates a new atom from its id.
    ///
    /// # Safety
    ///
    /// This function is unsafe because creating an `Atom`
    /// with an id that doesn't exist will result in undefined
    /// behavior. This should only be used by `Term` when converting
    /// to `TypedTerm`
    /// ```
    #[inline]
    pub unsafe fn from_id(id: usize) -> Self {
        Self(id)
    }

    // See https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L193-L212
    fn needs_quotes(&self) -> bool {
        let mut chars = self.name().chars();

        match chars.next() {
            Some(first_char) => {
                // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L198-L199
                // -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L98
                !first_char.is_ascii_lowercase() || {
                    // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L201-L200
                    // -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L102
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L91
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L91
                    //    -> https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L99
                    chars.any(|c| (!c.is_ascii_alphanumeric() && c != '_'))
                }
            }
            // https://github.com/erlang/otp/blob/ca83f680aab717fe65634247d16f18a8cbfc6d8d/erts/emulator/beam/erl_printf_term.c#L187-L190
            None => true,
        }
    }

    fn validate(name: &str) -> Result<(), AtomError> {
        let len = name.len();
        if len > MAX_ATOM_LENGTH {
            return Err(AtomError::InvalidLength(len));
        }
        Ok(())
    }
}

impl PartialEq<bool> for Atom {
    fn eq(&self, b: &bool) -> bool {
        // NOTE: This relies on the fact that we initialize the
        // atom table with 'false' at index 0, and 'true' at
        // index 1; and that Rust will convert bools to integers
        // such at false is 0 and true is 1
        let id = self.id();
        let b = *b;
        id == (b as usize)
    }
}
impl PartialEq<&str> for Atom {
    fn eq(&self, s: &&str) -> bool {
        self.name() == *s
    }
}

impl From<bool> for Atom {
    #[inline]
    fn from(b: bool) -> Self {
        // NOTE: We can make these assumptions because the AtomTable
        // is initialized in a deterministic way - it is critical that
        // if the initialization changes that these values get updated
        if b {
            Atom::TRUE
        } else {
            Atom::FALSE
        }
    }
}

impl Display for Atom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let needs_quotes = self.needs_quotes();

        if needs_quotes {
            f.write_char('\'')?;
        }

        for c in self.name().chars() {
            // https://github.com/erlang/otp/blob/dbf25321bdfdc3f4aae422b8ba2c0f31429eba61/erts/emulator/beam/erl_printf_term.c#L215-L232
            match c {
                '\'' => f.write_str("\\'")?,
                '\\' => f.write_str("\\\\")?,
                '\n' => f.write_str("\\n")?,
                '\u{C}' => f.write_str("\\f")?,
                '\t' => f.write_str("\\t")?,
                '\r' => f.write_str("\\r")?,
                '\u{8}' => f.write_str("\\b")?,
                '\u{B}' => f.write_str("\\v")?,
                _ if c.is_control() => write!(f, "\\{:o}", c as u8)?,
                _ => f.write_char(c)?,
            }
        }

        if needs_quotes {
            f.write_char('\'')?;
        }

        Ok(())
    }
}

impl Debug for Atom {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if let Some(name) = ATOMS.read().get_name(self.0) {
            f.write_str(":\"")?;
            name.chars()
                .flat_map(char::escape_default)
                .try_for_each(|c| f.write_char(c))?;
            f.write_char('\"')
        } else {
            f.debug_tuple("Atom").field(&self.0).finish()
        }
    }
}

impl PartialOrd for Atom {
    #[inline]
    fn partial_cmp(&self, other: &Atom) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl Ord for Atom {
    #[inline]
    fn cmp(&self, other: &Atom) -> cmp::Ordering {
        use cmp::Ordering;

        if self.0 == other.0 {
            return Ordering::Equal;
        }
        self.name().cmp(other.name())
    }
}

impl TryFrom<TypedTerm> for Atom {
    type Error = TypeError;

    fn try_from(typed_term: TypedTerm) -> Result<Self, Self::Error> {
        match typed_term {
            TypedTerm::Atom(atom) => Ok(atom),
            _ => Err(TypeError),
        }
    }
}

/// Produced by operations which create atoms
#[derive(Error, Debug)]
pub enum AtomError {
    #[error("exceeded system limit: maximum number of atoms ({})", MAX_ATOMS)]
    TooManyAtoms,
    #[error("invalid atom, length is {}, maximum length is {}", .0, MAX_ATOM_LENGTH)]
    InvalidLength(usize),
    #[error("tried to convert to an atom that doesn't exist")]
    NonExistent,
    #[error("invalid utf-8 bytes: {}", .0)]
    InvalidString(#[from] Utf8Error),
}
impl Eq for AtomError {}
impl PartialEq for AtomError {
    fn eq(&self, other: &AtomError) -> bool {
        mem::discriminant(self) == mem::discriminant(other)
    }
}

struct AtomTable {
    next_id: usize,
    ids: HashMap<&'static str, usize>,
    names: HashMap<usize, &'static str>,
    arena: DroplessArena,
}
impl AtomTable {
    const DEFAULT_ATOMS: &'static [&'static str] = &["false", "true"];

    fn new(names: &[&'static str]) -> Self {
        let len = names.len();
        let mut table = Self {
            next_id: 0,
            ids: HashMap::with_capacity(len),
            names: HashMap::with_capacity(len),
            arena: DroplessArena::default(),
        };
        let interned_names = &mut table.names;
        let next_id = &mut table.next_id;
        for name in names {
            table.ids.entry(name).or_insert_with(|| {
                let id = *next_id;
                *next_id += 1;
                interned_names.insert(id, name);
                id
            });
        }
        table
    }

    /// Used to initialize the atom table from an array of null-terminated strings with static
    /// lifetime, such as generated by codegen in order to initialize the atom table with
    /// constant atom values in the compiled program. It is expected that this will be called
    /// via `InitializeLumenAtomTable`
    unsafe fn from_raw(&mut self, raw_table: &'static [ConstantAtom]) -> anyhow::Result<()> {
        use std::ffi::CStr;

        let len = raw_table.len();

        self.next_id = 0;
        self.ids.clear();
        self.names.clear();

        self.ids.reserve(len);
        self.names.reserve(len);

        for ConstantAtom { id, value } in raw_table.iter() {
            let id = *id;
            // Ensure the 'next_id' is always one higher than the highest id we've seen
            if id >= self.next_id {
                self.next_id = id + 1;
            }
            // This is safe because the underlying data is static
            let cs = CStr::from_ptr::<'static>(*value);
            let name = cs.to_str().unwrap_or_else(|error| {
                panic!(
                    "invalid utf-8 ({:?}) in entry ({}) in atom table!",
                    error,
                    cs.to_string_lossy()
                )
            });
            assert_eq!(None, self.names.insert(id, name));
            assert_eq!(None, self.ids.insert(name, id));
        }

        assert!(self.next_id < MAX_ATOMS);

        Ok(())
    }

    fn get_id(&self, name: &str) -> Option<usize> {
        self.ids.get(name).cloned()
    }

    fn get_name(&self, id: usize) -> Option<&'static str> {
        self.names.get(&id).cloned()
    }

    fn get_id_or_insert(&mut self, name: &str) -> Result<usize, AtomError> {
        match self.get_id(name) {
            Some(existing_id) => Ok(existing_id),
            None => unsafe { self.insert(name) },
        }
    }

    // Unsafe because `name` should already have been checked as not existing while holding a
    // `mut reference`.
    unsafe fn insert(&mut self, name: &str) -> Result<usize, AtomError> {
        let id = self.next_id;
        self.next_id += 1;
        if id > MAX_ATOMS {
            return Err(AtomError::TooManyAtoms);
        }

        let size = name.len();

        let s = if size > 0 {
            // Copy string into arena
            let ptr = self.arena.alloc_raw(size, mem::align_of::<u8>());
            ptr::copy_nonoverlapping(name as *const _ as *const u8, ptr, size);
            let bytes = slice::from_raw_parts(ptr, size);

            str::from_utf8_unchecked(bytes)
        } else {
            ""
        };

        // Push into id map
        self.ids.insert(s, id);
        self.names.insert(id, s);

        Ok(id)
    }

    fn dump(&self) {
        for (id, name) in self.names.iter() {
            println!("atom(id = {}, value = '{}')", *id, name);
        }
    }
}
impl Default for AtomTable {
    fn default() -> Self {
        AtomTable::new(Self::DEFAULT_ATOMS)
    }
}

/// This is safe to implement because the only usage is the ATOMS static, which is wrapped in an
/// `RwLock`, but it is _not_ `Sync` in general, so don't try and use it as such in other situations
unsafe impl Sync for AtomTable {}

#[derive(Debug, Error)]
#[error("atom ({0}) is not supported")]
pub struct TryAtomFromTermError(pub &'static str);
