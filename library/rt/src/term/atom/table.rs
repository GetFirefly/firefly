use alloc::collections::HashMap;
use core::slice;
use core::str;

use lazy_static::lazy_static;

use liblumen_arena::DroplessArena;
use liblumen_system::sync::RwLock;

lazy_static! {
    /// The atom table used by the runtime system
    static ref ATOMS: RwLock<AtomTable> = Default::default();
}

#[derive(Copy, Clone, Debug)]
pub struct TryAtomFromTermError(pub &'static str);
impl fmt::Display for TryAtomFromTermError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "atom `{}` is not supported", self.0)
    }
}

/// This struct matches the layout of raw atom metadata in memory.
///
/// The compiler generates a record of this type for each atom, referencing the string
/// value of the atom elsewhere in memory (where depends on whether the atom was generated at
/// compile-time or runtime).
#[derive(Copy, Clone)]
#[repr(C)]
pub(super) struct AtomData {
    size: usize,
    ptr: *const u8,
}
impl AtomData {
    const FALSE_VALUE: &'static str = "false";
    const TRUE_VALUE: &'static str = "true";

    pub const FALSE: AtomData = AtomData {
        size: Self::FALSE_VALUE.len(),
        ptr: Self::FALSE_VALUE.as_ptr(),
    };
    pub const TRUE: AtomData = AtomData {
        size: Self::TRUE_VALUE.len(),
        ptr: Self::TRUE_VALUE.as_ptr(),
    };

    unsafe fn as_str(&self) -> &'static str {
        let bytes = unsafe { slice::from_raw_parts::<'static, _>(self.ptr, self.size) };
        str::from_utf8(bytes).unwrap()
    }
}

/// Performs one-time initialization of the atom table at program start, using the
/// array of constant atom values present in the compiled program.
///
/// It is expected that this will be called by code generated by the compiler, during the
/// earliest phase of startup, to ensure that nothing has tried to use the atom table yet.
#[export_name = "__lumen_initialize_atom_table"]
pub unsafe extern "C-unwind" fn init(start: *const AtomData, end: *const AtomData) -> bool {
    if start == end {
        return true;
    }
    if start.is_null() || end.is_null() {
        return false;
    }

    debug_assert_eq!(
        ((end as usize) - (start as usize)) % mem::size_of::<AtomData>(),
        0,
        "invalid atom data range"
    );
    let len = end.offset_from(start);
    let data = slice::from_raw_parts::<'static, _>(start, len);

    let mut default_table = ATOMS.write();
    default_table.extend(data);

    true
}

/// Like `get_data_or_insert`, but optimized for the case where the given atom value has static lifetime,
/// and thus doesn't require allocating space for and cloning the value. This is faster in that regard, but
/// still has all of the downsides that come with acquiring a write lock on the atom table.
#[inline]
pub(super) unsafe fn get_data_or_insert_static(name: &'static str) -> Result<NonNull<AtomData>, AtomError> {
    ATOMS.write().get_data_or_insert_static(name)
}

/// Gets the atom with the given name from the global atom table, or inserts it as a new atom if not present.
///
/// This operation acquires a write lock on the atom table, which requires exclusive access. This means this
/// operation must wait until all pre-existing readers/writers have released their locks, and will block all
/// subsequent readers/writers until it has completed. Since this is relatively expensive, this should only
/// be used when creating new atoms.
#[inline]
pub(super) unsafe fn get_data_or_insert(name: &str) -> Result<NonNull<AtomData>, AtomError> {
    ATOMS.write().get_data_or_insert(name)
}

/// Checks the global atom table for an atom by the given name, or returns None.
///
/// This operation acquires a read lock on the atom table, and so can run concurrently with other
/// readers, but will block if a writer is currently inserting into the table.
#[inline]
pub(super) fn get_data(name: &str) -> Option<NonNull<AtomData>> {
    ATOMS.read().get_data(name)
}

/// Dumps all of the atoms in the atom table to stdout
pub fn dump_atoms() {
    let table = ATOMS.read();
    table.dump();
}

/// This struct represents the atom table, of which a program will only ever have one at a time,
/// with static lifetime. The atoms it contains are never collected.
struct AtomTable {
    ids: HashMap<&'static str, NonNull<AtomData>>,
    arena: DroplessArena,
}
impl Default for AtomTable {
    fn default() -> Self {
        Self::new(Self::DEFAULT_ATOMS)
    }
}
impl AtomTable {
    const DEFAULT_ATOMS: &'static [AtomData] = [AtomData::FALSE, AtomData::TRUE];

    fn new(data: &'static [AtomData]) -> Self {
        let mut table = Self {
            ids: HashMap::with_capacity(100),
            arena: DroplessArena::default(),
        };
        self.extend(data);
        table
    }

    fn extend(&mut self, data: &'static [AtomData]) {
        for atom in data {
            let ptr = unsafe { NonNull::new_unchecked(atom as *const AtomData as *mut AtomData) };
            let name = unsafe { atom.as_str() };
            self.ids.entry(name).or_insert(ptr);
        }
    }

    fn get_data(&self, name: &str) -> Option<NonNull<AtomData>> {
        self.ids.get(name).copied()
    }

    fn get_data_or_insert(&mut self, name: &str) -> Result<NonNull<AtomData>, AtomError> {
        match self.get_data(name) {
            Some(existing_id) => Ok(existing_id),
            None => unsafe { self.insert(name) },
        }
    }

    // SAFETY: See insert_static for the safety constraints
    unsafe fn get_data_or_insert_static(&mut self, name: &'static str) -> Result<NonNull<AtomData>, AtomError> {
        match self.get_data(name) {
            Some(existing_id) => Ok(existing_id),
            None => self.insert_static(name),
        }
    }

    // SAFETY: You must ensure two things about the string passed to this function:
    //
    // * The string reference MUST have been derived from a CStr pointer. This is because
    // we assume that the pointer the reference is based on can be safely treated as a pointer
    // to a null-terminated string. If it can't, bad things will happen.
    // * The string you pass to this function MUST be truly valid for static lifetime, or
    // the behavior is undefined.
    //
    // This is intended to avoid wasting space on atoms which are already
    // stored in the read-only atom section constructed by the linker. This data is always valid for
    // the static lifetime, and so we can construct `&'static str` from them safely.
    unsafe fn insert_static(&mut self, name: &'static str) -> Result<NonNull<AtomData>, AtomError> {
        let bytes = name.as_bytes();
        let data = self.alloc_data(AtomData { ptr: bytes.as_ptr(), size: bytes.len() });
        self.ids.insert(name, data);

        Ok(data)
    }

    // This function is used to insert new atoms in the table during runtime
    // SAFETY: `name` must have been checked as not existing while holding the current mutable reference.
    unsafe fn insert(&mut self, name: &str) -> Result<NonNull<AtomData>, AtomError> {
        use core::intrinsics::unlikely;

        if unlikely(name.len() == 0) {
            let data = self.alloc_data(AtomData { ptr: ptr::null_mut(), size: 0 });
            self.ids.insert(name, data);

            return Ok(data);
        }

        // Allocate memory for atom metadata and value
        let bytes = name.as_bytes();
        let size = bytes.len();
        let (layout, value_offset) = Layout::new::<AtomData>()
            .extend(Layout::from_size_align_unchecked(size, mem::align_of::<u8>())
            .unwrap();
        let layout = layout.pad_to_align();
        let ptr = self.arena.alloc_raw(layout);

        let value_ptr = ptr.add(value_offset);
        let data_ptr: *mut AtomData = ptr.cast();
        // Write metadata
        data_ptr.write(AtomData { ptr: value_ptr, size: size });
        // Write atom data
        ptr::copy_nonoverlapping(bytes.as_ptr(), value_ptr, size);

        let data = NonNull::new_unchecked(data_ptr)

        // Register in atom table
        self.ids.insert(data.as_ref().as_str(), data);

        Ok(data)
    }

    unsafe fn alloc_data(data: AtomData) -> NonNull<AtomData> {
        let layout = Layout::new::<AtomData>();

        let ptr = self.arena.alloc_raw(layout);
        ptr.write(data);

        NonNull::new_unchecked(ptr)
    }

    fn dump(&self) {
        for (name, data) in self.ids.iter() {
            let atom = Atom(*data);
            println!("atom(value = {}, ptr = {:p})", &atom, data);
        }
    }
}
