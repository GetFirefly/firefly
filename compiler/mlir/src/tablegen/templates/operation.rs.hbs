{{#*inline "value_operand"}}
  {{#if isVariadic}}
    {{name}}: &[::liblumen_mlir::ir::Value]
  {{else}}
    {{#if isOptional}}
      {{name}}: Option<::liblumen_mlir::ir::Value>
    {{else}}
      {{name}}: ::liblumen_mlir::ir::Value
    {{/if}}
  {{/if}}
{{/inline}}

{{#*inline "attr_operand"}}
  {{#if isVariadic}}
    {{name}}: &[{{to_operand_type(attr.returnType)}}]
  {{else}}
    {{#if isOptional}}
      {{name}}: Option<{{to_operand_type(attr.returnType)}}>
    {{else}}
      {{name}}: {{to_operand_type(attr.returnType)}}
    {{/if}}
  {{/if}}
{{/inline}}

{{#*inline "operand"}}
  {{#if attr}}
    {{> attr_operand}}
  {{else}}
    {{> value_operand}}
  {{/if}}
{{/inline}}

{{#*inline "successor"}}
  {{#if isOptional}}
    {{name}}: Option<::liblumen_mlir::ir::Block>
  {{else}}
    {{name}}: ::liblumen_mlir::ir::Block
  {{/if}}
{{/inline}}

#[operation("{{mnemonic}}")]
pub struct {{name}};
impl {{name}} {
  {{#each results}}
  {{#if this.optional}}
  pub fn {{this.name}}(&self) -> Option<::liblumen_mlir::ir::Value> {
    self.get_result({{this.index}})
  }
  {{else}}
  pub fn {{this.name}}(&self) -> ::liblumen_mlir::ir::Value {
    self.get_result({{this.index}}).unwrap()
  }
  {{/if}}
  {{/each}}

  crate fn create(builder: &{{dialect.builder_name}}<'_>,
    , loc: ::liblumen_mlir::ir::Location
    {{#each operands as |arg|}}
      , {{~> operand arg}}
    {{/each}}
    {{! // If we don't know the result types in advance, require them as builder arguments }}
    {{#each result as |result|}}
      {{#if result.isVariadic or result.isOptional}}
        {{#if result.isVariadic}}
          , {{result.name}}: &[::liblumen_mlir::ir::Type]
        {{else}}
          , {{result.name}}: Option<::liblumen_mlir::ir::Type>
        {{/if}}
      {{/if}}
    {{/each}}
    {{#each successors as |s| }}
      , {{~> successor s}}
      , {{s.name}}_args: &[::liblumen_mlir::ir::Value]
    {{/each}}
  ) -> Self {
    let mut state = Self::build(loc);
    // Add all attributes this operation takes as arguments
    state.add_attributes(&[
      {{#with this as |op|}}
      {{#each attributes as |attr|}}
      builder.get_named_attr("{{attr.name}}", {{~> attr_builder attr op=op}}),
      {{/each}}
      {{/with}}
    ]);
    // Add all operands (i.e. Values) given as arguments
    {{#each operands as |arg|}}
      {{! // Attribute arguments are not operands }}
      {{#unless arg.attr}}
        {{#if arg.isVariadic}}
          state.add_operands({{arg.name}});
        {{else}}
          {{#if arg.isOptional}}
            if let Some(operand) = {{arg.name}} {
              state.add_operands(&[operand]);
            }
          {{else}}
            state.add_operands({{arg.name}}});
          {{/if}}
        {{/if}}
      {{/unless}}
    {{/each}}
    // Add all successor operands
    {{#each successors}}
      state.add_operands({{name}}_args);
    {{/each}}
    // Add all successor blocks
    state.add_successors(&[
      {{#each successors}}
        {{name}}
      {{/each}}
    ]);
    // Add all result types
    {{#each results as |result|}}
      {{#if result.isVariadic}}
        state.add_results(results);
      {{else}}
        {{#if result.isOptional}}
          if let Some(ty) = {{result.name}} {
            state.add_results(&[ty]);
          }
        {{else}}
          state.add_results(&[builder.get_{{to_snake_case(result.name)}}]);
        {{/if}}
      {{/if}}
    {{/each}}

    Self(builder.create_operation(state))
  }
}


impl<'a> {{dialect.builder_name}}<'a> {
    #[inline]
    pub fn create_{{to_rust_identifier(mnemonic)}}(
      &self,
      loc: ::liblumen_mlir::ir::Location,
      {{#each operands as |arg|}}
        , {{~> operand arg}}
      {{/each}}
      {{! // If we don't know the result types in advance, require them as builder arguments }}
      {{#each result as |result|}}
        {{#if result.isVariadic or result.isOptional}}
          {{#if result.isVariadic}}
            , {{result.name}}: &[::liblumen_mlir::ir::Type]
          {{else}}
            , {{result.name}}: Option<::liblumen_mlir::ir::Type>
          {{/if}}
        {{/if}}
      {{/each}}
      {{#each successors as |s| }}
        , {{~> successor s}}
        , {{s.name}}_args: &[::liblumen_mlir::ir::Value]
      {{/each}}
    ) -> {{name}} {
        {{name}}::create(
          self
          {{#each operands}}
            , {{name}}
          {{/each}}
          {{#each results}}
            {{#if isVariadic or isOptional}}
              , {{name}}
            {{/if}}
          {{/each}}
          {{#each successors}}
            {{name}}
          {{/each}}
        )
    }
}
