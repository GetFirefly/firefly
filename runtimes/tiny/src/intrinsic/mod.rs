use core::ops::Deref;
use core::ptr::NonNull;
use std::sync::Arc;

use num_bigint::{BigInt, Sign};

use liblumen_alloc::gc::GcBox;
use liblumen_binary::{BinaryEntrySpecifier, BitVec};
use liblumen_rt::backtrace::Trace;
use liblumen_rt::error::ErlangException;
use liblumen_rt::function::ErlangResult;
use liblumen_rt::term::{atoms, Atom, BigInteger, BinaryData, BitSlice, Closure, Cons, Map, Tuple};
use liblumen_rt::term::{MatchContext, MatchResult};
use liblumen_rt::term::{OpaqueTerm, Term, TermType};

use crate::scheduler;

/// Constructs a new empty term of the given type and size on the current process heap
#[export_name = "__lumen_builtin_malloc"]
pub extern "C-unwind" fn malloc(kind: TermType, size: usize) -> *mut () {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        match kind {
            TermType::Cons => Cons::new_in(proc).unwrap().as_ptr().cast(),
            TermType::Tuple => Tuple::new_in(size, proc).unwrap().as_ptr().cast(),
            TermType::Map => GcBox::into_raw(Map::new_in(proc).unwrap()).cast(),
            TermType::Closure => {
                GcBox::into_raw(unsafe { Closure::with_capacity_in(size, proc).unwrap() }).cast()
            }
            ty => panic!("unexpected malloc type: {:?}", ty),
        }
    })
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
#[allow(dead_code)]
enum SignRaw {
    Minus = 0,
    NoSign,
    Plus,
}
impl Into<Sign> for SignRaw {
    fn into(self) -> Sign {
        match self {
            Self::Minus => Sign::Minus,
            Self::NoSign => Sign::NoSign,
            Self::Plus => Sign::Plus,
        }
    }
}

#[repr(C)]
pub struct BigIntRef {
    sign: SignRaw,
    digits: [u8],
}

/// Allocates a new BigInteger from constant data produced by the compiler
#[export_name = "__lumen_bigint_from_digits"]
#[allow(improper_ctypes_definitions)]
pub extern "C" fn bigint_from_digits(raw: &BigIntRef) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        GcBox::new_in(
            BigInteger(BigInt::from_bytes_be(raw.sign.into(), &raw.digits[..])),
            proc,
        )
        .unwrap()
        .into()
    })
}

/// A combined tuple type test with fetching the arity, optimized for a specific pattern
/// produced by the compiler
#[export_name = "__lumen_tuple_size"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn tuple_size(term: OpaqueTerm) -> Result<u32, ()> {
    term.tuple_size()
}

/// A tuple constructor optimized for construction sequences generated by the compiler
#[export_name = "__lumen_make_tuple"]
pub extern "C-unwind" fn make_tuple(arity: usize) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        Tuple::new_in(arity, proc).unwrap().into()
    })
}

/// Intrinsic equivalent to erlang:setelement/3 that is optimized for cases in
/// which the callee is known to have a tuple reference and an immediate index,
/// allowing us to bypass the overhead of checking types on those two arguments.
///
/// NOTE: This is intended only for use by the code generator as a compiler intrinsic,
/// callers from Rust code should use the standard Tuple APIs. This is NOT safe to be
/// called from arbitrary user code, as it does not validate its invariants, and therefore
/// will result in undefined behavior if any of them are violated.
#[export_name = "__lumen_set_element"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn setelement(tuple: &Tuple, index: usize, value: OpaqueTerm) -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        tuple.set_element(index, value, proc).unwrap().into()
    })
}

/// Constructs a new empty map on the current process heap
#[export_name = "__lumen_map_empty"]
pub extern "C-unwind" fn map_empty() -> OpaqueTerm {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        Map::new_in(proc).unwrap().into()
    })
}

#[export_name = "__lumen_map_put"]
pub extern "C-unwind" fn map_put(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> OpaqueTerm {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            let updated = GcBox::new_in(m.insert(key.into(), value.into()), proc).unwrap();
            updated.into()
        }),
        _ => panic!("unexpected argument given to map_put bif"),
    }
}

#[export_name = "__lumen_map_put_mut"]
pub extern "C-unwind" fn map_put_mut(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> OpaqueTerm {
    match map.into() {
        Term::Map(mut m) => {
            m.insert_mut(key.into(), value.into());
            map
        }
        _ => panic!("unexpected argument given to map_put bif"),
    }
}

#[export_name = "__lumen_map_update"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_update(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> ErlangResult {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            match m.insert_new(key.into(), value.into()) {
                None => Err(map_error(key, Trace::capture())),
                Some(updated) => Ok(GcBox::new_in(updated, proc).unwrap().into()),
            }
        }),
        _ => panic!("unexpected argument given to map_update bif"),
    }
}

#[export_name = "__lumen_map_update_mut"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_update_mut(
    map: OpaqueTerm,
    key: OpaqueTerm,
    value: OpaqueTerm,
) -> ErlangResult {
    match map.into() {
        Term::Map(m) => scheduler::with_current(|scheduler| {
            let arc_proc = scheduler.current_process();
            let proc = arc_proc.deref();
            match m.insert_new(key.into(), value.into()) {
                None => Err(map_error(key, Trace::capture())),
                Some(updated) => Ok(GcBox::new_in(updated, proc).unwrap().into()),
            }
        }),
        _ => panic!("unexpected argument given to map_update_mut bif"),
    }
}

#[inline]
fn map_error(key: OpaqueTerm, trace: Arc<Trace>) -> NonNull<ErlangException> {
    let exception = ErlangException::new(atoms::Error, key.into(), trace);
    unsafe { NonNull::new_unchecked(Box::into_raw(exception)) }
}

/// This builtin differs from erlang:map_get/2 in that it is only called in contexts where
/// we've already type checked the map, and we're simply fetching the given key from the map
#[export_name = "__lumen_map_fetch"]
#[allow(improper_ctypes_definitions)]
pub extern "C-unwind" fn map_fetch(map: OpaqueTerm, key: OpaqueTerm) -> Result<OpaqueTerm, ()> {
    match map.into() {
        Term::Map(m) => {
            let key: Term = key.into();
            m.get(&key).map(|t| t.into()).ok_or(())
        }
        _ => Err(()),
    }
}

#[export_name = "__lumen_build_stacktrace"]
pub unsafe extern "C-unwind" fn build_stacktrace(mut trace: NonNull<Trace>) -> OpaqueTerm {
    let term = trace.as_mut().as_term().unwrap();
    term.into()
}

#[export_name = "__lumen_builtin_raise/3"]
pub extern "C-unwind" fn raise(
    kind: OpaqueTerm,
    reason: OpaqueTerm,
    trace: *mut Trace,
) -> *mut ErlangException {
    debug_assert!(!trace.is_null());
    let trace = unsafe { Trace::from_raw(trace) };
    let kind: Term = kind.into();
    let kind: Atom = kind.try_into().unwrap();
    let exception = match kind.as_str() {
        "throw" | "error" | "exit" => ErlangException::new(kind, reason.into(), trace),
        other => panic!("invalid exception kind: {}", &other),
    };
    Box::into_raw(exception)
}

#[export_name = "__lumen_cleanup_exception"]
pub extern "C-unwind" fn cleanup(ptr: *mut ErlangException) {
    let _ = unsafe { Box::from_raw(ptr) };
}

#[export_name = "__lumen_builtin_yield"]
pub unsafe extern "C-unwind" fn process_yield() -> bool {
    scheduler::with_current(|scheduler| scheduler.process_yield())
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_builtin_exit"]
pub unsafe extern "C-unwind" fn process_exit(result: ErlangResult) {
    scheduler::with_current(|scheduler| {
        match result {
            Ok(_) => {
                scheduler.current_process().exit_normal();
            }
            Err(err) => {
                scheduler.current_process().exit_error(err);
            }
        }

        scheduler.process_yield()
    });
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_init"]
pub extern "C-unwind" fn bs_init() -> Result<NonNull<BitVec>, ()> {
    let buffer = Box::new(BitVec::new());
    Ok(unsafe { NonNull::new_unchecked(Box::into_raw(buffer)) })
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_push"]
pub extern "C-unwind" fn bs_push(
    mut bin: NonNull<BitVec>,
    spec: BinaryEntrySpecifier,
    value: OpaqueTerm,
    size: OpaqueTerm,
) -> Result<NonNull<BitVec>, NonNull<ErlangException>> {
    let buffer = unsafe { bin.as_mut() };
    match spec {
        BinaryEntrySpecifier::Integer {
            signed,
            unit,
            endianness,
        } => match (value.into(), size.into()) {
            (Term::Int(i), Term::Int(size)) => {
                if signed {
                    buffer.push_ap_number(i, (unit as usize) * (size as usize), endianness);
                } else {
                    buffer.push_ap_number(i as u64, (unit as usize) * (size as usize), endianness);
                }
                Ok(bin)
            }
            (Term::BigInt(i), Term::Int(size)) => {
                buffer.push_ap_bigint(
                    i.deref(),
                    (unit as usize) * (size as usize),
                    signed,
                    endianness,
                );
                Ok(bin)
            }
            _ => Err(badarg(Trace::capture())),
        },
        BinaryEntrySpecifier::Float { unit, endianness } => match (value.into(), size.into()) {
            (Term::Float(f), Term::Int(size)) => match (unit as usize) * (size as usize) {
                64 => {
                    buffer.push_number(f.as_f64(), endianness);
                    Ok(bin)
                }
                _ => todo!("bs.push float"),
            },
            _ => Err(badarg(Trace::capture())),
        },
        BinaryEntrySpecifier::Binary { unit } => match (value.into(), size.into()) {
            (Term::ConstantBinary(bin), Term::Int(size)) => {
                let bitsize = (unit as usize) * (size as usize);
                todo!()
            }
            _ => Err(badarg(Trace::capture())),
        },
        BinaryEntrySpecifier::Utf8 => match (value.into(), size.into()) {
            (Term::Int(i), Term::Int(size)) => {
                let Ok(codepoint) = i.try_into() else { return Err(badarg(Trace::capture())); };
                let Some(c) = char::from_u32(codepoint) else { return Err(badarg(Trace::capture())); };
                buffer.push_utf8(c);
                Ok(bin)
            }
            _ => Err(badarg(Trace::capture())),
        },
        BinaryEntrySpecifier::Utf16 { endianness } => match (value.into(), size.into()) {
            (Term::Int(i), Term::Int(size)) => {
                let Ok(codepoint) = i.try_into() else { return Err(badarg(Trace::capture())); };
                let Some(c) = char::from_u32(codepoint) else { return Err(badarg(Trace::capture())); };
                buffer.push_utf16(c, endianness);
                Ok(bin)
            }
            _ => Err(badarg(Trace::capture())),
        },
        BinaryEntrySpecifier::Utf32 { endianness } => match (value.into(), size.into()) {
            (Term::Int(i), Term::Int(size)) => {
                let Ok(codepoint) = i.try_into() else { return Err(badarg(Trace::capture())); };
                let Some(c) = char::from_u32(codepoint) else { return Err(badarg(Trace::capture())); };
                buffer.push_utf32(c, endianness);
                Ok(bin)
            }
            _ => Err(badarg(Trace::capture())),
        },
    }
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_finish"]
pub extern "C-unwind" fn bs_finish(buffer: NonNull<BitVec>) -> Result<OpaqueTerm, ()> {
    use liblumen_binary::Bitstring;

    let buffer = unsafe { Box::from_raw(buffer.as_ptr()) };
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        match buffer.byte_size() {
            0 => {
                let bin = BinaryData::with_capacity_small(0, proc).unwrap();
                Ok(bin.into())
            }
            n if n <= 64 => {
                let bin = BinaryData::with_capacity_small(n, proc).unwrap();
                Ok(bin.into())
            }
            n => {
                let bin = BinaryData::with_capacity_large(n, proc).unwrap();
                Ok(bin.into())
            }
        }
    })
}

#[allow(improper_ctypes_definitions)]
#[export_name = "__lumen_bs_match_start"]
pub extern "C-unwind" fn bs_match_start(
    bin: OpaqueTerm,
) -> Result<NonNull<MatchContext>, NonNull<ErlangException>> {
    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        let boxed = MatchContext::new(bin, proc).unwrap();
        Ok(unsafe { NonNull::new_unchecked(GcBox::into_raw(boxed)) })
    })
}

#[export_name = "__lumen_bs_match"]
pub extern "C-unwind" fn bs_match(
    mut ctx: NonNull<MatchContext>,
    spec: BinaryEntrySpecifier,
    size: OpaqueTerm,
) -> MatchResult {
    use half::f16;

    scheduler::with_current(|scheduler| {
        let arc_proc = scheduler.current_process();
        let proc = arc_proc.deref();
        let context = unsafe { ctx.as_mut() };
        let matcher = context.matcher();
        match spec {
            BinaryEntrySpecifier::Integer {
                signed,
                unit,
                endianness,
            } => {
                let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
                let size: usize = size.try_into().expect("invalid size");
                let bitsize = unit as usize * size;
                if bitsize == 0 {
                    MatchResult::ok(OpaqueTerm::ZERO, ctx)
                } else if bitsize > 52 {
                    match matcher.match_bigint(bitsize, signed, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => {
                            let big = GcBox::new_in(BigInteger(i), proc).unwrap();
                            MatchResult::ok(OpaqueTerm::from(big), ctx)
                        }
                    }
                } else if signed {
                    match matcher.match_ap_number::<i64, 8>(bitsize, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => MatchResult::ok(i.try_into().unwrap(), ctx),
                    }
                } else {
                    match matcher.match_ap_number::<u64, 8>(bitsize, endianness) {
                        None => MatchResult::err(ctx),
                        Some(i) => MatchResult::ok((i as i64).try_into().unwrap(), ctx),
                    }
                }
            }
            BinaryEntrySpecifier::Float { unit, endianness } => {
                let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
                let size: usize = size.try_into().expect("invalid size");
                let bitsize = unit as usize * size;
                match bitsize {
                    0 => MatchResult::ok(0.0f64.into(), ctx),
                    16 => match matcher.match_number::<f16, 2>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(n) => {
                            let f: f64 = n.into();
                            MatchResult::ok(f.into(), ctx)
                        }
                    },
                    32 => match matcher.match_number::<f32, 4>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(n) => {
                            let f: f64 = n.into();
                            MatchResult::ok(f.into(), ctx)
                        }
                    },
                    64 => match matcher.match_number::<f64, 8>(endianness) {
                        None => MatchResult::err(ctx),
                        Some(f) => MatchResult::ok(f.into(), ctx),
                    },
                    _ => MatchResult::err(ctx),
                }
            }
            BinaryEntrySpecifier::Binary { unit } => {
                let Term::Int(size) = size.into() else { panic!("expected an immediate integer") };
                let size: usize = size.try_into().expect("invalid size");
                let bitsize = unit as usize * size;
                match matcher.match_bits(bitsize) {
                    None => MatchResult::err(ctx),
                    Some(selection) => {
                        let bin = GcBox::new_in(
                            BitSlice::from_selection(context.owner(), selection),
                            proc,
                        )
                        .unwrap();
                        MatchResult::ok(OpaqueTerm::from(bin), ctx)
                    }
                }
            }
            BinaryEntrySpecifier::Utf8 => match matcher.match_utf8() {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
            BinaryEntrySpecifier::Utf16 { endianness } => match matcher.match_utf16(endianness) {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
            BinaryEntrySpecifier::Utf32 { endianness } => match matcher.match_utf32(endianness) {
                None => MatchResult::err(ctx),
                Some(c) => MatchResult::ok(c.into(), ctx),
            },
        }
    })
}

/// Tests the tail of the current match context matches the given size in bits
#[export_name = "__lumen_bs_test_tail"]
pub unsafe extern "C-unwind" fn bs_test_tail(ctx: NonNull<MatchContext>, size: usize) -> bool {
    ctx.as_ref().bits_remaining() == size
}

pub(self) fn badarg(trace: Arc<Trace>) -> NonNull<ErlangException> {
    crate::erlang::raise2(atoms::Badarg.into(), unsafe {
        NonNull::new_unchecked(Trace::into_raw(trace))
    })
    .unwrap_err()
}
