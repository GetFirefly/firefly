mod dynamic;

pub use self::dynamic::DynamicCallee;

use core::alloc::Layout;
use core::mem;
use core::slice;

use hashbrown::{HashMap, HashSet};
use lazy_static::lazy_static;

use firefly_arena::DroplessArena;
use firefly_system::sync::RwLock;

use crate::term::{Atom, OpaqueTerm};

use super::{ErlangResult, FunctionSymbol, ModuleFunctionArity};

lazy_static! {
    /// The symbol table used by the runtime system
    static ref SYMBOLS: RwLock<SymbolTable> = Default::default();
}

/// Dynamically invokes the function mapped to the given symbol.
///
/// - The caller is responsible for making sure that the given symbol
/// belongs to a function compiled into the executable.
/// - The caller must ensure that the target function adheres to the ABI
/// requirements of the destination function:
///   - C calling convention
///   - Accepts only immediate-sized terms as arguments
///   - Returns an immediate-sized term as a result
///
/// This function returns `Err` if the called function returns the NONE value,
/// or if the given symbol doesn't exist.
///
/// This function will panic if the symbol table has not been initialized.
pub fn apply(symbol: &ModuleFunctionArity, args: &[OpaqueTerm]) -> Result<ErlangResult, ()> {
    if let Some(f) = find_symbol(symbol) {
        Ok(unsafe { dynamic::apply(f, args.as_ptr(), args.len()) })
    } else {
        Err(())
    }
}

pub unsafe fn apply_callee(callee: DynamicCallee, args: &[OpaqueTerm]) -> ErlangResult {
    dynamic::apply(callee, args.as_ptr(), args.len())
}

pub fn find_symbol(mfa: &ModuleFunctionArity) -> Option<DynamicCallee> {
    if let Some(f) = SYMBOLS.read().get_function(mfa) {
        Some(unsafe { mem::transmute::<*const (), DynamicCallee>(f) })
    } else {
        None
    }
}

pub fn module_loaded(module: Atom) -> bool {
    SYMBOLS.read().contains_module(module)
}

/// Performs one-time initialization of the atom table at program start, using the
/// array of constant atom values present in the compiled program.
///
/// It is expected that this will be called by code generated by the compiler, during the
/// earliest phase of startup, to ensure that nothing has tried to use the atom table yet.
#[export_name = "__firefly_initialize_dispatch_table"]
pub unsafe extern "C-unwind" fn init(
    start: *const FunctionSymbol,
    end: *const FunctionSymbol,
) -> bool {
    if start == end {
        return true;
    }
    if start.is_null() || end.is_null() {
        return false;
    }

    debug_assert_eq!(
        ((end as usize) - (start as usize)) % mem::size_of::<FunctionSymbol>(),
        0,
        "invalid function symbol range"
    );

    let len = end.offset_from(start);
    let data = slice::from_raw_parts::<'static, _>(start, len as usize);

    let mut table = SYMBOLS.write();
    for symbol in data.iter().copied() {
        let module = symbol.module;
        let function = symbol.function;
        let arity = symbol.arity;
        let callee = symbol.ptr;

        let size = mem::size_of::<ModuleFunctionArity>();
        let align = mem::align_of::<ModuleFunctionArity>();
        let layout = Layout::from_size_align(size, align).unwrap();
        let ptr = table.arena.alloc_raw(layout) as *mut ModuleFunctionArity;
        ptr.write(ModuleFunctionArity {
            module,
            function,
            arity,
        });
        let sym = mem::transmute::<&ModuleFunctionArity, &'static ModuleFunctionArity>(&*ptr);
        assert_eq!(None, table.idents.insert(callee, sym));
        assert_eq!(None, table.functions.insert(sym, callee));
        table.modules.insert(sym.module);
    }

    true
}

struct SymbolTable {
    functions: HashMap<&'static ModuleFunctionArity, *const ()>,
    idents: HashMap<*const (), &'static ModuleFunctionArity>,
    modules: HashSet<Atom>,
    arena: DroplessArena,
}
impl SymbolTable {
    fn new(size: usize) -> Self {
        Self {
            functions: HashMap::with_capacity(size),
            idents: HashMap::with_capacity(size),
            modules: HashSet::new(),
            arena: DroplessArena::default(),
        }
    }

    #[allow(unused)]
    fn get_ident(&self, function: *const ()) -> Option<&'static ModuleFunctionArity> {
        self.idents.get(&function).copied()
    }

    fn get_function(&self, ident: &ModuleFunctionArity) -> Option<*const ()> {
        self.functions.get(ident).copied()
    }

    fn contains_module(&self, module: Atom) -> bool {
        self.modules.contains(&module)
    }
}
impl Default for SymbolTable {
    fn default() -> Self {
        SymbolTable::new(100)
    }
}

// These are safe to implement because the items in the symbol table are static
unsafe impl Sync for SymbolTable {}
unsafe impl Send for SymbolTable {}
